{"/home/travis/build/npmtest/node-npmtest-dredd/test.js":"/* istanbul instrument in package npmtest_dredd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dredd/lib.npmtest_dredd.js":"/* istanbul instrument in package npmtest_dredd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_dredd = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_dredd = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-dredd/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-dredd && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_dredd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_dredd\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_dredd.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_dredd.rollup.js'] =\n            local.assetsDict['/assets.npmtest_dredd.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_dredd.__dirname + '/lib.npmtest_dredd.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/dredd.js":"// Generated by CoffeeScript 1.12.5\nvar Dredd, FILE_DOWNLOAD_TIMEOUT, PROXY_ENV_VARIABLES, Runner, applyConfiguration, async, clone, configureReporters, dreddTransactions, fs, glob, handleRuntimeProblems, logger, options, removeDuplicates, request, url,\n  hasProp = {}.hasOwnProperty,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nglob = require('glob');\n\nfs = require('fs');\n\nclone = require('clone');\n\nasync = require('async');\n\nrequest = require('request');\n\nurl = require('url');\n\nlogger = require('./logger');\n\noptions = require('./options');\n\nRunner = require('./transaction-runner');\n\napplyConfiguration = require('./configuration').applyConfiguration;\n\nhandleRuntimeProblems = require('./handle-runtime-problems');\n\ndreddTransactions = require('dredd-transactions');\n\nconfigureReporters = require('./configure-reporters');\n\nPROXY_ENV_VARIABLES = ['HTTP_PROXY', 'HTTPS_PROXY', 'NO_PROXY'];\n\nFILE_DOWNLOAD_TIMEOUT = 5000;\n\nremoveDuplicates = function(arr) {\n  return arr.reduce(function(alreadyProcessed, currentItem) {\n    if (alreadyProcessed.indexOf(currentItem) === -1) {\n      return alreadyProcessed.concat(currentItem);\n    }\n    return alreadyProcessed;\n  }, []);\n};\n\nDredd = (function() {\n  function Dredd(config) {\n    this.init(config);\n  }\n\n  Dredd.prototype.init = function(config) {\n    this.configuration = applyConfiguration(config);\n    this.configuration.http = {};\n    this.tests = [];\n    this.stats = {\n      tests: 0,\n      failures: 0,\n      errors: 0,\n      passes: 0,\n      skipped: 0,\n      start: 0,\n      end: 0,\n      duration: 0\n    };\n    this.transactions = [];\n    this.runner = new Runner(this.configuration);\n    configureReporters(this.configuration, this.stats, this.tests, this.runner);\n    return this.logProxySettings();\n  };\n\n  Dredd.prototype.logProxySettings = function() {\n    var envVariableName, envVariableValue, message, proxySettings, ref, ref1;\n    proxySettings = [];\n    ref = process.env;\n    for (envVariableName in ref) {\n      if (!hasProp.call(ref, envVariableName)) continue;\n      envVariableValue = ref[envVariableName];\n      if (ref1 = envVariableName.toUpperCase(), indexOf.call(PROXY_ENV_VARIABLES, ref1) < 0) {\n        continue;\n      }\n      if (envVariableValue === '') {\n        continue;\n      }\n      proxySettings.push(envVariableName + \"=\" + envVariableValue);\n    }\n    if (proxySettings.length) {\n      message = \"HTTP(S) proxy specified by environment variables: \" + (proxySettings.join(', ')) + \". Please read documentation on how Dredd works with proxies: https://dredd.readthedocs.io/en/latest/how-it-works/#using-https-proxy\";\n      return logger.verbose(message);\n    }\n  };\n\n  Dredd.prototype.run = function(callback) {\n    var base, base1, key, passedConfigData, ref, val;\n    this.configDataIsEmpty = true;\n    if ((base = this.configuration).files == null) {\n      base.files = [];\n    }\n    if ((base1 = this.configuration).data == null) {\n      base1.data = {};\n    }\n    passedConfigData = {};\n    ref = this.configuration.data || {};\n    for (key in ref) {\n      if (!hasProp.call(ref, key)) continue;\n      val = ref[key];\n      this.configDataIsEmpty = false;\n      if (typeof val === 'string') {\n        passedConfigData[key] = {\n          filename: key,\n          raw: val\n        };\n      } else if ((typeof val === 'object') && val.raw && val.filename) {\n        passedConfigData[val.filename] = {\n          filename: val.filename,\n          raw: val.raw\n        };\n      }\n    }\n    if (!this.configDataIsEmpty) {\n      this.configuration.data = passedConfigData;\n    }\n    this.configuration.options.path = removeDuplicates(this.configuration.options.path);\n    logger.verbose('Expanding glob patterns.');\n    return this.expandGlobs((function(_this) {\n      return function(globsErr) {\n        if (globsErr) {\n          return callback(globsErr, _this.stats);\n        }\n        logger.verbose('Reading API description files.');\n        return _this.loadFiles(function(loadErr) {\n          if (loadErr) {\n            return callback(loadErr, _this.stats);\n          }\n          logger.verbose('Parsing API description files and compiling a list of HTTP transactions to test.');\n          return _this.compileTransactions(function(compileErr) {\n            if (compileErr) {\n              return callback(compileErr, _this.stats);\n            }\n            logger.verbose('Starting reporters and waiting until all of them are ready.');\n            return _this.emitStart(function(emitStartErr) {\n              if (emitStartErr) {\n                return callback(emitStartErr, _this.stats);\n              }\n              logger.verbose('Starting transaction runner.');\n              return _this.startRunner(function(runnerErr) {\n                if (runnerErr) {\n                  return callback(runnerErr, _this.stats);\n                }\n                logger.verbose('Wrapping up testing.');\n                return _this.transactionsComplete(callback);\n              });\n            });\n          });\n        });\n      };\n    })(this));\n  };\n\n  Dredd.prototype.expandGlobs = function(callback) {\n    return async.each(this.configuration.options.path, (function(_this) {\n      return function(globToExpand, globCallback) {\n        if (/^http(s)?:\\/\\//.test(globToExpand)) {\n          _this.configuration.files = _this.configuration.files.concat(globToExpand);\n          return globCallback();\n        }\n        return glob(globToExpand, function(err, match) {\n          if (err) {\n            return globCallback(err);\n          }\n          _this.configuration.files = _this.configuration.files.concat(match);\n          return globCallback();\n        });\n      };\n    })(this), (function(_this) {\n      return function(err) {\n        if (err) {\n          return callback(err, _this.stats);\n        }\n        if (_this.configDataIsEmpty && _this.configuration.files.length === 0) {\n          err = new Error(\"API description document (or documents) not found on path: '\" + _this.configuration.options.path + \"'\");\n          return callback(err, _this.stats);\n        }\n        _this.configuration.files = removeDuplicates(_this.configuration.files);\n        return callback(null, _this.stats);\n      };\n    })(this));\n  };\n\n  Dredd.prototype.loadFiles = function(callback) {\n    return async.eachLimit(this.configuration.files, 6, (function(_this) {\n      return function(fileUrlOrPath, loadCallback) {\n        var host, protocol, ref;\n        ref = url.parse(fileUrlOrPath), protocol = ref.protocol, host = ref.host;\n        if (host && (protocol === 'http:' || protocol === 'https:')) {\n          logger.verbose('Downloading remote file:', fileUrlOrPath);\n          return _this.downloadFile(fileUrlOrPath, loadCallback);\n        } else {\n          return _this.readLocalFile(fileUrlOrPath, loadCallback);\n        }\n      };\n    })(this), callback);\n  };\n\n  Dredd.prototype.downloadFile = function(fileUrl, callback) {\n    options = clone(this.configuration.http);\n    options.url = fileUrl;\n    options.timeout = FILE_DOWNLOAD_TIMEOUT;\n    return request.get(options, (function(_this) {\n      return function(downloadError, res, body) {\n        var err;\n        if (downloadError) {\n          logger.debug(\"Downloading \" + fileUrl + \" errored:\", (\"\" + downloadError) || downloadError.code);\n          err = new Error(\"Error when loading file from URL '\" + fileUrl + \"'. Is the provided URL correct?\");\n          return callback(err, _this.stats);\n        }\n        if (!body || res.statusCode < 200 || res.statusCode >= 300) {\n          err = new Error(\"Unable to load file from URL '\" + fileUrl + \"'. Server did not send any blueprint back and responded with status code \" + res.statusCode + \".\");\n          return callback(err, _this.stats);\n        }\n        _this.configuration.data[fileUrl] = {\n          raw: body,\n          filename: fileUrl\n        };\n        return callback(null, _this.stats);\n      };\n    })(this));\n  };\n\n  Dredd.prototype.readLocalFile = function(filePath, callback) {\n    return fs.readFile(filePath, 'utf8', (function(_this) {\n      return function(readError, data) {\n        var err;\n        if (readError) {\n          err = new Error(\"Error when reading file '\" + filePath + \"' (\" + readError.message + \"). Is the provided path correct?\");\n          return callback(err);\n        }\n        _this.configuration.data[filePath] = {\n          raw: data,\n          filename: filePath\n        };\n        return callback(null, _this.stats);\n      };\n    })(this));\n  };\n\n  Dredd.prototype.compileTransactions = function(callback) {\n    this.transactions = [];\n    return async.each(Object.keys(this.configuration.data), (function(_this) {\n      return function(filename, next) {\n        var fileData;\n        fileData = _this.configuration.data[filename];\n        if (fileData.annotations == null) {\n          fileData.annotations = [];\n        }\n        logger.verbose('Compiling HTTP transactions from API description file:', filename);\n        return dreddTransactions.compile(fileData.raw, filename, function(compilationError, compilationResult) {\n          var error, i, j, len, len1, ref, ref1, warning;\n          if (compilationError) {\n            return next(compilationError);\n          }\n          ref = compilationResult.errors;\n          for (i = 0, len = ref.length; i < len; i++) {\n            error = ref[i];\n            error.type = 'error';\n            fileData.annotations.push(error);\n          }\n          ref1 = compilationResult.warnings;\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            warning = ref1[j];\n            warning.type = 'warning';\n            fileData.annotations.push(warning);\n          }\n          fileData.mediaType = compilationResult.mediaType;\n          _this.transactions = _this.transactions.concat(compilationResult.transactions);\n          return next();\n        });\n      };\n    })(this), (function(_this) {\n      return function(runtimeError) {\n        if (runtimeError == null) {\n          runtimeError = handleRuntimeProblems(_this.configuration.data);\n        }\n        return callback(runtimeError, _this.stats);\n      };\n    })(this));\n  };\n\n  Dredd.prototype.emitStart = function(callback) {\n    var reporterCount, reporterErrorOccurred;\n    reporterCount = this.configuration.emitter.listeners('start').length;\n    reporterErrorOccurred = false;\n    return this.configuration.emitter.emit('start', this.configuration.data, (function(_this) {\n      return function(reporterError) {\n        reporterCount--;\n        if (reporterError && reporterErrorOccurred === false) {\n          reporterErrorOccurred = true;\n          return callback(reporterError, _this.stats);\n        }\n        if (reporterCount === 0 && reporterErrorOccurred === false) {\n          return callback(null, _this.stats);\n        }\n      };\n    })(this));\n  };\n\n  Dredd.prototype.startRunner = function(callback) {\n    this.runner.config(this.configuration);\n    return this.runner.run(this.transactions, callback);\n  };\n\n  Dredd.prototype.transactionsComplete = function(callback) {\n    var reporterCount;\n    reporterCount = this.configuration.emitter.listeners('end').length;\n    return this.configuration.emitter.emit('end', (function(_this) {\n      return function() {\n        reporterCount--;\n        if (reporterCount === 0) {\n          return callback(null, _this.stats);\n        }\n      };\n    })(this));\n  };\n\n  return Dredd;\n\n})();\n\nmodule.exports = Dredd;\n\nmodule.exports.options = options;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/bin/dredd":"#!/usr/bin/env node\n\nvar fs = require('fs');\nvar path = require('path');\n\n\n// Ignore this block, it's pure magic, temporary fix\n// for https://github.com/nodejs/node/issues/6456\n[process.stdout, process.stderr].forEach(function (s) {\n  s && s.isTTY && s._handle && s._handle.setBlocking && s._handle.setBlocking(true);\n});\n\n\nvar dir = process.env.COVERAGE_DIR ? 'src' : 'lib';\nvar DreddCommand = require('../' + dir + '/dredd-command');\n\n\nvar dreddCli = new DreddCommand({\n  custom: {\n    cwd: process.cwd(),\n    argv: process.argv.slice(2)\n  },\n  exit: exit\n});\n\n\nfunction exit(exitStatus) {\n  if (process.env.COVERAGE_DIR) {\n    // Before Dredd exits, we need to collect coverage stats and save them to\n    // a file. We abuse 'mocha-lcov-reporter' to do this.\n    var LCov = require('mocha-lcov-reporter');\n\n    // Pretending there is Mocha runner\n    var EventEmitter = require('events').EventEmitter;\n    var runner = new EventEmitter();\n\n    // Monkey-patching 'LCov.prototype.write' to catch all output to a variable\n    var content = '';\n    var write = LCov.prototype.write;\n\n    LCov.prototype.write = function(string) {\n      content += string;\n    }\n\n    // Collecting the stats\n    new LCov(runner);\n    runner.emit('end');\n\n    // Undo the monkey-patching\n    LCov.prototype.write = write;\n\n    // Save stats as lcov file\n    var file = path.join(process.env.COVERAGE_DIR, 'dredd-bin.info');\n    fs.appendFileSync(file, content);\n  }\n\n  process.exit(exitStatus);\n}\n\n\ndreddCli.run();\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/dredd-command.js":"// Generated by CoffeeScript 1.12.5\nvar Dredd, DreddCommand, applyLoggingOptions, configUtils, console, exports, fs, interactiveConfig, logger, optimist, os, packageData, path, spawn, spawnArgs, spawnSync;\n\npath = require('path');\n\noptimist = require('optimist');\n\nfs = require('fs');\n\nos = require('os');\n\nspawnArgs = require('spawn-args');\n\nspawnSync = require('cross-spawn').sync;\n\nconsole = require('console');\n\nDredd = require('./dredd');\n\ninteractiveConfig = require('./interactive-config');\n\napplyLoggingOptions = require('./configuration').applyLoggingOptions;\n\nconfigUtils = require('./config-utils');\n\nspawn = require('./child-process').spawn;\n\nlogger = require('./logger');\n\npackageData = require('../package.json');\n\nDreddCommand = (function() {\n  function DreddCommand(options, cb) {\n    if (options == null) {\n      options = {};\n    }\n    this.cb = cb;\n    this.finished = false;\n    this.exit = options.exit, this.custom = options.custom;\n    this.setExitOrCallback();\n    if (this.custom == null) {\n      this.custom = {};\n    }\n    if (!this.custom.cwd || typeof this.custom.cwd !== 'string') {\n      this.custom.cwd = process.cwd();\n    }\n    if (!this.custom.argv || !Array.isArray(this.custom.argv)) {\n      this.custom.argv = [];\n    }\n  }\n\n  DreddCommand.prototype.setOptimistArgv = function() {\n    this.optimist = optimist(this.custom.argv, this.custom.cwd);\n    this.cliArgv = this.optimist.argv;\n    this.optimist.usage('Usage:\\n  $ dredd init\\n\\nOr:\\n  $ dredd <path or URL to API description document> <URL of tested server> [OPTIONS]\\n\\nExample:\\n  $ dredd ./api-description.apib http://127.0.0.1:3000 --dry-run').options(Dredd.options).wrap(80);\n    this.argv = this.optimist.argv;\n    return this.argv = applyLoggingOptions(this.argv);\n  };\n\n  DreddCommand.prototype.stopServer = function(callback) {\n    if (this.serverProcess == null) {\n      logger.verbose('No backend server process to terminate.');\n      return callback();\n    }\n    if (this.serverProcess.terminated) {\n      logger.debug('The backend server process has already terminated');\n      return callback();\n    }\n    logger.verbose('Terminating backend server process, PID', this.serverProcess.pid);\n    this.serverProcess.terminate({\n      force: true\n    });\n    return this.serverProcess.on('exit', function() {\n      return callback();\n    });\n  };\n\n  DreddCommand.prototype.setExitOrCallback = function() {\n    if (!this.cb) {\n      if (this.exit && (this.exit === process.exit)) {\n        this.sigIntEventAdd = true;\n      }\n      if (this.exit) {\n        return this._processExit = (function(_this) {\n          return function(exitStatus) {\n            logger.verbose(\"Exiting Dredd process with status '\" + exitStatus + \"'.\");\n            logger.debug('Using configured custom exit() method to terminate the Dredd process.');\n            _this.finished = true;\n            return _this.stopServer(function() {\n              return _this.exit(exitStatus);\n            });\n          };\n        })(this);\n      } else {\n        return this._processExit = (function(_this) {\n          return function(exitStatus) {\n            logger.verbose(\"Exiting Dredd process with status '\" + exitStatus + \"'.\");\n            logger.debug('Using native process.exit() method to terminate the Dredd process.');\n            return _this.stopServer(function() {\n              return process.exit(exitStatus);\n            });\n          };\n        })(this);\n      }\n    } else {\n      return this._processExit = (function(_this) {\n        return function(exitStatus) {\n          logger.verbose(\"Exiting Dredd process with status '\" + exitStatus + \"'.\");\n          logger.debug('Using configured custom callback to terminate the Dredd process.');\n          _this.finished = true;\n          if (_this.sigIntEventAdded) {\n            if ((_this.serverProcess != null) && !_this.serverProcess.terminated) {\n              logger.verbose('Killing backend server process before Dredd exits.');\n              _this.serverProcess.signalKill();\n            }\n            process.removeEventListener('SIGINT', _this.commandSigInt);\n          }\n          _this.cb(exitStatus);\n          return _this;\n        };\n      })(this);\n    }\n  };\n\n  DreddCommand.prototype.moveBlueprintArgToPath = function() {\n    if (!Array.isArray(this.argv['path'])) {\n      return this.argv['path'] = this.argv['p'] = [this.argv['path']];\n    }\n  };\n\n  DreddCommand.prototype.checkRequiredArgs = function() {\n    var argError;\n    argError = false;\n    if (this.argv._[0] == null) {\n      console.error(\"\\nError: Must specify path to API description document.\");\n      argError = true;\n    }\n    if (this.argv._[1] == null) {\n      console.error(\"\\nError: Must specify URL of the tested API instance.\");\n      argError = true;\n    }\n    if (argError) {\n      console.error(\"\\n\");\n      this.optimist.showHelp(console.error);\n      return this._processExit(1);\n    }\n  };\n\n  DreddCommand.prototype.runExitingActions = function() {\n    if (this.argv[\"_\"][0] === \"init\" || this.argv.init === true) {\n      logger.silly('Starting interactive configuration.');\n      this.finished = true;\n      return interactiveConfig.run(this.argv, (function(_this) {\n        return function(config) {\n          configUtils.save(config);\n          console.log(\"\");\n          console.log(\"Configuration saved to dredd.yml\");\n          console.log(\"\");\n          if (config['language'] === \"nodejs\") {\n            console.log(\"Run test now, with:\");\n          } else {\n            console.log(\"Install hooks handler and run Dredd test with:\");\n          }\n          console.log(\"\");\n          if (config['language'] === 'ruby') {\n            console.log(\"  $ gem install dredd_hooks\");\n          } else if (config['language'] === 'python') {\n            console.log(\"  $ pip install dredd_hooks\");\n          } else if (config['language'] === 'php') {\n            console.log(\"  $ composer require ddelnano/dredd-hooks-php --dev\");\n          } else if (config['language'] === 'perl') {\n            console.log(\"  $ cpanm Dredd::Hooks\");\n          } else if (config['language'] === 'go') {\n            console.log(\"  $ go get github.com/snikch/goodman/cmd/goodman\");\n          }\n          console.log(\"  $ dredd\");\n          console.log(\"\");\n          return _this._processExit(0);\n        };\n      })(this));\n    } else if (this.argv.help === true) {\n      logger.silly('Printing help.');\n      this.optimist.showHelp(console.error);\n      return this._processExit(0);\n    } else if (this.argv.version === true) {\n      logger.silly('Printing version.');\n      console.log(packageData.name + \" v\" + packageData.version + \" (\" + (os.type()) + \" \" + (os.release()) + \"; \" + (os.arch()) + \")\");\n      return this._processExit(0);\n    }\n  };\n\n  DreddCommand.prototype.loadDreddFile = function() {\n    var configPath, key, ref, value;\n    configPath = this.argv.config;\n    logger.verbose('Loading configuration file:', configPath);\n    if (configPath && fs.existsSync(configPath)) {\n      logger.info(\"Configuration '\" + configPath + \"' found, ignoring other arguments.\");\n      this.argv = configUtils.load(configPath);\n    }\n    ref = this.cliArgv;\n    for (key in ref) {\n      value = ref[key];\n      if (key !== \"_\" && key !== \"$0\") {\n        this.argv[key] = value;\n      }\n    }\n    return this.argv = applyLoggingOptions(this.argv);\n  };\n\n  DreddCommand.prototype.parseCustomConfig = function() {\n    return this.argv.custom = configUtils.parseCustom(this.argv.custom);\n  };\n\n  DreddCommand.prototype.runServerAndThenDredd = function(callback) {\n    var command, parsedArgs, waitMilis, waitSecs;\n    if (this.argv['server'] == null) {\n      logger.verbose('No backend server process specified, starting testing at once');\n      return this.runDredd(this.dreddInstance);\n    } else {\n      logger.verbose('Backend server process specified, starting backend server and then testing');\n      parsedArgs = spawnArgs(this.argv['server']);\n      command = parsedArgs.shift();\n      logger.verbose(\"Using '\" + command + \"' as a server command, \" + (JSON.stringify(parsedArgs)) + \" as arguments\");\n      this.serverProcess = spawn(command, parsedArgs);\n      logger.info(\"Starting backend server process with command: \" + this.argv['server']);\n      this.serverProcess.stdout.setEncoding('utf8');\n      this.serverProcess.stdout.on('data', function(data) {\n        return process.stdout.write(data.toString());\n      });\n      this.serverProcess.stderr.setEncoding('utf8');\n      this.serverProcess.stderr.on('data', function(data) {\n        return process.stdout.write(data.toString());\n      });\n      this.serverProcess.on('signalTerm', function() {\n        return logger.verbose('Gracefully terminating the backend server process');\n      });\n      this.serverProcess.on('signalKill', function() {\n        return logger.verbose('Killing the backend server process');\n      });\n      this.serverProcess.on('crash', (function(_this) {\n        return function(exitStatus, killed) {\n          if (killed) {\n            return logger.info('Backend server process was killed');\n          }\n        };\n      })(this));\n      this.serverProcess.on('exit', (function(_this) {\n        return function() {\n          return logger.info('Backend server process exited');\n        };\n      })(this));\n      this.serverProcess.on('error', (function(_this) {\n        return function(error) {\n          logger.error('Command to start backend server process failed, exiting Dredd', error);\n          return _this._processExit(2);\n        };\n      })(this));\n      process.on('beforeExit', (function(_this) {\n        return function() {\n          if ((_this.serverProcess != null) && !_this.serverProcess.terminated) {\n            logger.verbose('Killing backend server process before Dredd exits');\n            return _this.serverProcess.signalKill();\n          }\n        };\n      })(this));\n      process.on('exit', (function(_this) {\n        return function() {\n          if ((_this.serverProcess != null) && !_this.serverProcess.terminated) {\n            logger.verbose('Killing backend server process on Dredd\\'s exit');\n            return _this.serverProcess.signalKill();\n          }\n        };\n      })(this));\n      waitSecs = parseInt(this.argv['server-wait'], 10);\n      waitMilis = waitSecs * 1000;\n      logger.info(\"Waiting \" + waitSecs + \" seconds for backend server process to start\");\n      return this.wait = setTimeout((function(_this) {\n        return function() {\n          return _this.runDredd(_this.dreddInstance);\n        };\n      })(this), waitMilis);\n    }\n  };\n\n  DreddCommand.prototype.logDebuggingInfo = function(config) {\n    var err, npmVersion;\n    logger.debug('Dredd version:', packageData.version);\n    logger.debug('Node.js version:', process.version);\n    logger.debug('Node.js environment:', process.versions);\n    logger.debug('System version:', os.type(), os.release(), os.arch());\n    try {\n      npmVersion = spawnSync('npm', ['--version']).stdout.toString().trim();\n      logger.debug('npm version:', npmVersion || 'unable to determine npm version');\n    } catch (error1) {\n      err = error1;\n      logger.debug('npm version: unable to determine npm version:', err);\n    }\n    return logger.debug('Configuration:', JSON.stringify(config));\n  };\n\n  DreddCommand.prototype.run = function() {\n    var configurationForDredd, e, i, len, ref, task;\n    ref = [this.setOptimistArgv, this.parseCustomConfig, this.runExitingActions, this.loadDreddFile, this.checkRequiredArgs, this.moveBlueprintArgToPath];\n    for (i = 0, len = ref.length; i < len; i++) {\n      task = ref[i];\n      task.call(this);\n      if (this.finished) {\n        return;\n      }\n    }\n    configurationForDredd = this.initConfig();\n    this.logDebuggingInfo(configurationForDredd);\n    this.dreddInstance = this.initDredd(configurationForDredd);\n    try {\n      this.runServerAndThenDredd();\n    } catch (error1) {\n      e = error1;\n      logger.error(e.message, e.stack);\n      this.stopServer((function(_this) {\n        return function() {\n          return _this._processExit(2);\n        };\n      })(this));\n    }\n  };\n\n  DreddCommand.prototype.lastArgvIsApiEndpoint = function() {\n    this.server = this.argv._[this.argv._.length - 1];\n    this.argv._.splice(this.argv._.length - 1, 1);\n    return this;\n  };\n\n  DreddCommand.prototype.takeRestOfParamsAsPath = function() {\n    this.argv['p'] = this.argv['path'] = this.argv['path'].concat(this.argv._);\n    return this;\n  };\n\n  DreddCommand.prototype.initConfig = function() {\n    var base, configuration;\n    this.lastArgvIsApiEndpoint().takeRestOfParamsAsPath();\n    configuration = {\n      'server': this.server,\n      'options': this.argv\n    };\n    if ((base = configuration.options).path == null) {\n      base.path = [];\n    }\n    configuration.options.path.push(this.argv._[0]);\n    configuration.custom = this.custom;\n    return configuration;\n  };\n\n  DreddCommand.prototype.initDredd = function(configuration) {\n    return new Dredd(configuration);\n  };\n\n  DreddCommand.prototype.commandSigInt = function() {\n    logger.error('\\nShutting down from keyboard interruption (Ctrl+C)');\n    return this.dreddInstance.transactionsComplete((function(_this) {\n      return function() {\n        return _this._processExit(0);\n      };\n    })(this));\n  };\n\n  DreddCommand.prototype.runDredd = function(dreddInstance) {\n    if (this.sigIntEventAdd) {\n      this.sigIntEventAdded = !(this.sigIntEventAdd = false);\n      process.on('SIGINT', this.commandSigInt);\n    }\n    logger.verbose('Running Dredd instance.');\n    dreddInstance.run((function(_this) {\n      return function(error, stats) {\n        logger.verbose('Dredd instance run finished.');\n        return _this.exitWithStatus(error, stats);\n      };\n    })(this));\n    return this;\n  };\n\n  DreddCommand.prototype.exitWithStatus = function(error, stats) {\n    if (error) {\n      if (error.message) {\n        logger.error(error.message);\n      }\n      return this._processExit(1);\n    }\n    if ((stats.failures + stats.errors) > 0) {\n      this._processExit(1);\n    } else {\n      this._processExit(0);\n    }\n  };\n\n  return DreddCommand;\n\n})();\n\nexports = module.exports = DreddCommand;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/add-hooks.js":"// Generated by CoffeeScript 1.12.5\nvar Hooks, HooksWorkerClient, addHooks, async, clone, fs, glob, logger, mergeSandboxedHooks, path, proxyquire, sandboxHooksCode;\n\nrequire('coffee-script/register');\n\npath = require('path');\n\nproxyquire = require('proxyquire').noCallThru();\n\nglob = require('glob');\n\nfs = require('fs');\n\nasync = require('async');\n\nclone = require('clone');\n\nHooks = require('./hooks');\n\nlogger = require('./logger');\n\nsandboxHooksCode = require('./sandbox-hooks-code');\n\nmergeSandboxedHooks = require('./merge-sandboxed-hooks');\n\nHooksWorkerClient = require('./hooks-worker-client');\n\naddHooks = function(runner, transactions, callback) {\n  var base, customConfigCwd, file, files, fixLegacyTransactionNames, globItem, globs, hooksWorkerClient, i, j, k, len, len1, len2, loadHookFile, loadSandboxHooksFromStrings, msg, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, transaction;\n  customConfigCwd = runner != null ? (ref = runner.configuration) != null ? (ref1 = ref.custom) != null ? ref1.cwd : void 0 : void 0 : void 0;\n  fixLegacyTransactionNames = function(allHooks) {\n    var hookType, hooks, i, len, newTransactionName, pattern, ref2, results, transactionName;\n    pattern = /^\\s>\\s/g;\n    ref2 = ['beforeHooks', 'afterHooks'];\n    results = [];\n    for (i = 0, len = ref2.length; i < len; i++) {\n      hookType = ref2[i];\n      results.push((function() {\n        var ref3, results1;\n        ref3 = allHooks[hookType];\n        results1 = [];\n        for (transactionName in ref3) {\n          hooks = ref3[transactionName];\n          if (transactionName.match(pattern) !== null) {\n            newTransactionName = transactionName.replace(pattern, '');\n            if (allHooks[hookType][newTransactionName] !== void 0) {\n              allHooks[hookType][newTransactionName] = hooks.concat(allHooks[hookType][newTransactionName]);\n            } else {\n              allHooks[hookType][newTransactionName] = hooks;\n            }\n            results1.push(delete allHooks[hookType][transactionName]);\n          } else {\n            results1.push(void 0);\n          }\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n  loadHookFile = function(filename, basePath) {\n    var error, filePath;\n    if (basePath == null) {\n      basePath = customConfigCwd || process.cwd();\n    }\n    filePath = path.resolve(basePath, filename);\n    try {\n      proxyquire(filePath, {\n        'hooks': runner.hooks\n      });\n      return fixLegacyTransactionNames(runner.hooks);\n    } catch (error1) {\n      error = error1;\n      return logger.warn(\"Skipping hook loading. Error reading hook file '\" + filePath + \"'. This probably means one or more of your hook files are invalid.\\nMessage: \" + error.message + \"\\nStack: \" + error.stack);\n    }\n  };\n  loadSandboxHooksFromStrings = function(callback) {\n    if (typeof runner.configuration.hooksData !== 'object' || Array.isArray(runner.configuration.hooksData) !== false) {\n      return callback(new Error(\"hooksData option must be an object e.g. {'filename.js':'console.log(\\\"Hey!\\\")'}\"));\n    }\n    return async.eachSeries(Object.keys(runner.configuration.hooksData), function(key, nextHook) {\n      var data;\n      data = runner.configuration.hooksData[key];\n      return sandboxHooksCode(data, function(sandboxError, result) {\n        if (sandboxError) {\n          return nextHook(sandboxError);\n        }\n        runner.hooks = mergeSandboxedHooks(runner.hooks, result);\n        fixLegacyTransactionNames(runner.hooks);\n        return nextHook();\n      });\n    }, callback);\n  };\n  if (runner.logs == null) {\n    runner.logs = [];\n  }\n  runner.hooks = new Hooks({\n    logs: runner.logs,\n    logger: logger\n  });\n  if ((base = runner.hooks).transactions == null) {\n    base.transactions = {};\n  }\n  for (i = 0, len = transactions.length; i < len; i++) {\n    transaction = transactions[i];\n    runner.hooks.transactions[transaction.name] = transaction;\n  }\n  if (!(runner != null ? (ref2 = runner.configuration) != null ? (ref3 = ref2.options) != null ? ref3.hookfiles : void 0 : void 0 : void 0)) {\n    if (runner.configuration.hooksData != null) {\n      if (runner.configuration.options.sandbox === true) {\n        return loadSandboxHooksFromStrings(callback);\n      } else {\n        msg = 'Not sandboxed hooks loading from strings is not implemented, Sandbox mode must be enabled when loading hooks from strings.';\n        return callback(new Error(msg));\n      }\n    } else {\n      return callback();\n    }\n  } else {\n    runner.hooks.configuration = clone(runner != null ? runner.configuration : void 0);\n    files = [];\n    globs = [].concat(runner != null ? (ref4 = runner.configuration) != null ? (ref5 = ref4.options) != null ? ref5.hookfiles : void 0 : void 0 : void 0);\n    for (j = 0, len1 = globs.length; j < len1; j++) {\n      globItem = globs[j];\n      files = files.concat(glob.sync(globItem));\n    }\n    logger.info('Found Hookfiles:', files);\n    if (!runner.configuration.options.sandbox === true) {\n      if ((runner != null ? (ref6 = runner.configuration) != null ? (ref7 = ref6.options) != null ? ref7.language : void 0 : void 0 : void 0) === \"\" || (runner != null ? (ref8 = runner.configuration) != null ? (ref9 = ref8.options) != null ? ref9.language : void 0 : void 0 : void 0) === void 0 || (runner != null ? (ref10 = runner.configuration) != null ? (ref11 = ref10.options) != null ? ref11.language : void 0 : void 0 : void 0) === \"nodejs\") {\n        for (k = 0, len2 = files.length; k < len2; k++) {\n          file = files[k];\n          loadHookFile(file);\n        }\n        return callback();\n      } else {\n        hooksWorkerClient = new HooksWorkerClient(runner);\n        return hooksWorkerClient.start(callback);\n      }\n    } else {\n      logger.info('Loading hook files in sandboxed context:', files);\n      return async.eachSeries(files, function(fileName, nextFile) {\n        var resolvedPath;\n        resolvedPath = path.resolve(customConfigCwd || process.cwd(), fileName);\n        return fs.readFile(resolvedPath, 'utf8', function(readingError, data) {\n          if (readingError) {\n            return nextFile(readingError);\n          }\n          return sandboxHooksCode(data, function(sandboxError, result) {\n            if (sandboxError) {\n              return nextFile(sandboxError);\n            }\n            runner.hooks = mergeSandboxedHooks(runner.hooks, result);\n            fixLegacyTransactionNames(runner.hooks);\n            return nextFile();\n          });\n        });\n      }, callback);\n    }\n  }\n};\n\nmodule.exports = addHooks;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/hooks.js":"// Generated by CoffeeScript 1.12.5\nvar Hooks, hooksLog,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  slice = [].slice;\n\nhooksLog = require('./hooks-log');\n\nHooks = (function() {\n  function Hooks(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.dumpHooksFunctionsToStrings = bind(this.dumpHooksFunctionsToStrings, this);\n    this.log = bind(this.log, this);\n    this.afterEach = bind(this.afterEach, this);\n    this.beforeEachValidation = bind(this.beforeEachValidation, this);\n    this.beforeEach = bind(this.beforeEach, this);\n    this.afterAll = bind(this.afterAll, this);\n    this.beforeAll = bind(this.beforeAll, this);\n    this.after = bind(this.after, this);\n    this.beforeValidation = bind(this.beforeValidation, this);\n    this.before = bind(this.before, this);\n    this.logs = options.logs, this.logger = options.logger;\n    this.transactions = {};\n    this.beforeHooks = {};\n    this.beforeValidationHooks = {};\n    this.afterHooks = {};\n    this.beforeAllHooks = [];\n    this.afterAllHooks = [];\n    this.beforeEachHooks = [];\n    this.beforeEachValidationHooks = [];\n    this.afterEachHooks = [];\n  }\n\n  Hooks.prototype.before = function(name, hook) {\n    return this.addHook(this.beforeHooks, name, hook);\n  };\n\n  Hooks.prototype.beforeValidation = function(name, hook) {\n    return this.addHook(this.beforeValidationHooks, name, hook);\n  };\n\n  Hooks.prototype.after = function(name, hook) {\n    return this.addHook(this.afterHooks, name, hook);\n  };\n\n  Hooks.prototype.beforeAll = function(hook) {\n    return this.beforeAllHooks.push(hook);\n  };\n\n  Hooks.prototype.afterAll = function(hook) {\n    return this.afterAllHooks.push(hook);\n  };\n\n  Hooks.prototype.beforeEach = function(hook) {\n    return this.beforeEachHooks.push(hook);\n  };\n\n  Hooks.prototype.beforeEachValidation = function(hook) {\n    return this.beforeEachValidationHooks.push(hook);\n  };\n\n  Hooks.prototype.afterEach = function(hook) {\n    return this.afterEachHooks.push(hook);\n  };\n\n  Hooks.prototype.addHook = function(hooks, name, hook) {\n    if (hooks[name]) {\n      return hooks[name].push(hook);\n    } else {\n      return hooks[name] = [hook];\n    }\n  };\n\n  Hooks.prototype.log = function() {\n    var args;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    this.logs = hooksLog.apply(null, [this.logs, this.logger].concat(slice.call(args)));\n  };\n\n  Hooks.prototype.dumpHooksFunctionsToStrings = function() {\n    var funcArray, hookFunc, i, index, len, names, property, ref, ref1, toReturn, transactionName;\n    toReturn = {};\n    names = ['beforeHooks', 'beforeValidationHooks', 'afterHooks', 'beforeAllHooks', 'afterAllHooks', 'beforeEachHooks', 'beforeEachValidationHooks', 'afterEachHooks'];\n    for (i = 0, len = names.length; i < len; i++) {\n      property = names[i];\n      if (Array.isArray(this[property])) {\n        toReturn[property] = [];\n        ref = this[property];\n        for (index in ref) {\n          hookFunc = ref[index];\n          toReturn[property][index] = hookFunc.toString();\n        }\n      } else if (typeof this[property] === 'object' && !Array.isArray(this[property])) {\n        toReturn[property] = {};\n        ref1 = this[property];\n        for (transactionName in ref1) {\n          funcArray = ref1[transactionName];\n          if (!funcArray.length) {\n            continue;\n          }\n          toReturn[property][transactionName] = [];\n          for (index in funcArray) {\n            hookFunc = funcArray[index];\n            toReturn[property][transactionName][index] = hookFunc.toString();\n          }\n        }\n      }\n    }\n    return toReturn;\n  };\n\n  return Hooks;\n\n})();\n\nmodule.exports = Hooks;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/hooks-log.js":"// Generated by CoffeeScript 1.12.5\nvar hooksLog, util;\n\nutil = require('util');\n\nhooksLog = function(logs, logger, content) {\n  if (logs == null) {\n    logs = [];\n  }\n  if (logger != null) {\n    if (typeof logger.hook === \"function\") {\n      logger.hook(content);\n    }\n  }\n  if (logs != null) {\n    if (typeof logs.push === \"function\") {\n      logs.push({\n        timestamp: Date.now(),\n        content: typeof content === 'object' ? util.format(content) : \"\" + content\n      });\n    }\n  }\n  return logs;\n};\n\nmodule.exports = hooksLog;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/logger.js":"// Generated by CoffeeScript 1.12.5\nvar winston;\n\nwinston = require('winston');\n\nmodule.exports = new winston.Logger({\n  transports: [\n    new winston.transports.Console({\n      colorize: true\n    })\n  ],\n  levels: {\n    silly: 14,\n    debug: 13,\n    verbose: 12,\n    info: 11,\n    test: 10,\n    pass: 9,\n    fail: 8,\n    complete: 7,\n    actual: 6,\n    expected: 5,\n    hook: 4,\n    request: 3,\n    skip: 2,\n    warn: 1,\n    error: 0\n  },\n  colors: {\n    silly: 'gray',\n    debug: 'cyan',\n    verbose: 'magenta',\n    info: 'blue',\n    test: 'yellow',\n    pass: 'green',\n    fail: 'red',\n    complete: 'green',\n    actual: 'red',\n    expected: 'red',\n    hook: 'green',\n    request: 'green',\n    skip: 'yellow',\n    warn: 'yellow',\n    error: 'red'\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/sandbox-hooks-code.js":"// Generated by CoffeeScript 1.12.5\nvar Hooks, Pitboss, sandboxHooksCode;\n\nPitboss = require('pitboss-ng').Pitboss;\n\nHooks = require('./hooks');\n\nsandboxHooksCode = function(hooksCode, callback) {\n  var hooks, sandbox, wrappedCode;\n  hooks = new Hooks();\n  wrappedCode = \"var _hooks = new _Hooks();\\n\\nvar before = _hooks.before;\\nvar after = _hooks.after;\\nvar beforeAll = _hooks.beforeAll;\\nvar afterAll = _hooks.afterAll;\\nvar beforeEach = _hooks.beforeEach;\\nvar afterEach = _hooks.afterEach;\\nvar beforeValidation = _hooks.beforeValidation;\\nvar beforeEachValidation = _hooks.beforeEachValidation;\\n\\nvar log = _hooks.log;\\n\\n\" + hooksCode + \"\\ntry {\\n  var output = _hooks.dumpHooksFunctionsToStrings();\\n} catch(e) {\\n  console.log(e.message);\\n  console.log(e.stack);\\n  throw(e);\\n}\\n\\noutput\";\n  sandbox = new Pitboss(wrappedCode);\n  sandbox.run({\n    libraries: {\n      '_Hooks': '../../../lib/hooks',\n      'console': 'console'\n    }\n  }, function(err, result) {\n    sandbox.kill();\n    if (err) {\n      return callback(err);\n    }\n    callback(void 0, result);\n  });\n};\n\nmodule.exports = sandboxHooksCode;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/merge-sandboxed-hooks.js":"// Generated by CoffeeScript 1.12.5\nvar clone, mergeSandboxedHooks;\n\nclone = require('clone');\n\nmergeSandboxedHooks = function(original, toMerge) {\n  var base, funcArray, functions, newHooks, target, transactionName;\n  newHooks = clone(original);\n  for (target in toMerge) {\n    functions = toMerge[target];\n    if (Array.isArray(functions)) {\n      newHooks[target] = newHooks[target].concat(functions);\n    } else if (typeof functions === \"object\" && !Array.isArray(functions)) {\n      for (transactionName in functions) {\n        funcArray = functions[transactionName];\n        if ((base = newHooks[target])[transactionName] == null) {\n          base[transactionName] = [];\n        }\n        newHooks[target][transactionName] = newHooks[target][transactionName].concat(funcArray);\n      }\n    }\n  }\n  return newHooks;\n};\n\nmodule.exports = mergeSandboxedHooks;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/hooks-worker-client.js":"// Generated by CoffeeScript 1.12.5\nvar EventEmitter, HooksWorkerClient, generateUuid, logger, net, spawn, spawnArgs, which,\n  hasProp = {}.hasOwnProperty;\n\nnet = require('net');\n\nEventEmitter = require('events').EventEmitter;\n\nspawnArgs = require('spawn-args');\n\ngenerateUuid = require('uuid').v4;\n\nspawn = require('./child-process').spawn;\n\nlogger = require('./logger');\n\nwhich = require('./which');\n\nHooksWorkerClient = (function() {\n  function HooksWorkerClient(runner) {\n    var options;\n    this.runner = runner;\n    options = this.runner.hooks.configuration.options;\n    this.language = options.language;\n    this.timeout = options['hooks-worker-timeout'] || 5000;\n    this.connectTimeout = options['hooks-worker-connect-timeout'] || 1500;\n    this.connectRetry = options['hooks-worker-connect-retry'] || 500;\n    this.afterConnectWait = options['hooks-worker-after-connect-wait'] || 100;\n    this.termTimeout = options['hooks-worker-term-timeout'] || 5000;\n    this.termRetry = options['hooks-worker-term-retry'] || 500;\n    this.handlerHost = options['hooks-worker-handler-host'] || '127.0.0.1';\n    this.handlerPort = options['hooks-worker-handler-port'] || 61321;\n    this.handlerMessageDelimiter = '\\n';\n    this.clientConnected = false;\n    this.connectError = false;\n    this.emitter = new EventEmitter;\n  }\n\n  HooksWorkerClient.prototype.start = function(callback) {\n    logger.verbose('Looking up hooks handler implementation:', this.language);\n    return this.setCommandAndCheckForExecutables((function(_this) {\n      return function(executablesError) {\n        if (executablesError) {\n          return callback(executablesError);\n        }\n        logger.verbose('Starting hooks handler.');\n        return _this.spawnHandler(function(spawnHandlerError) {\n          if (spawnHandlerError) {\n            return callback(spawnHandlerError);\n          }\n          logger.verbose('Connecting to hooks handler.');\n          return _this.connectToHandler(function(connectHandlerError) {\n            if (connectHandlerError) {\n              return callback(connectHandlerError);\n            }\n            logger.verbose('Registering hooks.');\n            return _this.registerHooks(function(registerHooksError) {\n              if (registerHooksError) {\n                return callback(registerHooksError);\n              }\n              return callback();\n            });\n          });\n        });\n      };\n    })(this));\n  };\n\n  HooksWorkerClient.prototype.stop = function(callback) {\n    this.disconnectFromHandler();\n    return this.terminateHandler(callback);\n  };\n\n  HooksWorkerClient.prototype.terminateHandler = function(callback) {\n    logger.verbose('Terminating hooks handler process, PID', this.handler.pid);\n    if (this.handler.terminated) {\n      logger.debug('The hooks handler process has already terminated');\n      return callback();\n    }\n    this.handler.terminate({\n      force: true,\n      timeout: this.termTimeout,\n      retryDelay: this.termRetry\n    });\n    return this.handler.on('close', function() {\n      return callback();\n    });\n  };\n\n  HooksWorkerClient.prototype.disconnectFromHandler = function() {\n    return this.handlerClient.destroy();\n  };\n\n  HooksWorkerClient.prototype.setCommandAndCheckForExecutables = function(callback) {\n    var gobin, msg, parsedArgs;\n    if (this.language === 'ruby') {\n      this.handlerCommand = 'dredd-hooks-ruby';\n      this.handlerCommandArgs = [];\n      if (!which.which(this.handlerCommand)) {\n        msg = \"Ruby hooks handler command not found: \" + this.handlerCommand + \"\\nInstall ruby hooks handler by running:\\n$ gem install dredd_hooks\";\n        return callback(new Error(msg));\n      } else {\n        return callback();\n      }\n    } else if (this.language === 'python') {\n      this.handlerCommand = 'dredd-hooks-python';\n      this.handlerCommandArgs = [];\n      if (!which.which(this.handlerCommand)) {\n        msg = \"Python hooks handler command not found: \" + this.handlerCommand + \"\\nInstall python hooks handler by running:\\n$ pip install dredd_hooks\";\n        return callback(new Error(msg));\n      } else {\n        return callback();\n      }\n    } else if (this.language === 'php') {\n      this.handlerCommand = 'dredd-hooks-php';\n      this.handlerCommandArgs = [];\n      if (!which.which(this.handlerCommand)) {\n        msg = \"PHP hooks handler command not found: \" + this.handlerCommand + \"\\nInstall php hooks handler by running:\\n$ composer require ddelnano/dredd-hooks-php --dev\";\n        return callback(new Error(msg));\n      } else {\n        return callback();\n      }\n    } else if (this.language === 'perl') {\n      this.handlerCommand = 'dredd-hooks-perl';\n      this.handlerCommandArgs = [];\n      if (!which.which(this.handlerCommand)) {\n        msg = \"Perl hooks handler command not found: \" + this.handlerCommand + \"\\nInstall perl hooks handler by running:\\n$ cpanm Dredd::Hooks\";\n        return callback(new Error(msg));\n      } else {\n        return callback();\n      }\n    } else if (this.language === 'nodejs') {\n      msg = 'Hooks handler should not be used for Node.js. Use Dredd\\'s native Node.js hooks instead.';\n      return callback(new Error(msg));\n    } else if (this.language === 'go') {\n      gobin = process.env.GOBIN;\n      if (!gobin) {\n        gobin = process.env.GOPATH + \"/bin\";\n      }\n      this.handlerCommand = gobin + \"/goodman\";\n      this.handlerCommandArgs = [];\n      if (!which.which(this.handlerCommand)) {\n        msg = 'Go hooks handler command not found in $GOBIN or $GOPATH/bin\\nInstall go hooks handler by running:\\n$ go get github.com/snikch/goodman/cmd/goodman';\n        return callback(new Error(msg));\n      } else {\n        return callback();\n      }\n    } else {\n      parsedArgs = spawnArgs(this.language);\n      this.handlerCommand = parsedArgs.shift();\n      this.handlerCommandArgs = parsedArgs;\n      logger.verbose(\"Using '\" + this.handlerCommand + \"' as a hook handler command, '\" + (this.handlerCommandArgs.join(' ')) + \"' as arguments\");\n      if (!which.which(this.handlerCommand)) {\n        msg = \"Hooks handler command not found: \" + this.handlerCommand;\n        return callback(new Error(msg));\n      } else {\n        return callback();\n      }\n    }\n  };\n\n  HooksWorkerClient.prototype.spawnHandler = function(callback) {\n    var handlerCommandArgs, pathGlobs, ref, ref1, ref2;\n    pathGlobs = [].concat((ref = this.runner.hooks) != null ? (ref1 = ref.configuration) != null ? (ref2 = ref1.options) != null ? ref2.hookfiles : void 0 : void 0 : void 0);\n    handlerCommandArgs = this.handlerCommandArgs.concat(pathGlobs);\n    logger.info(\"Spawning '\" + this.language + \"' hooks handler process.\");\n    this.handler = spawn(this.handlerCommand, handlerCommandArgs);\n    this.handler.stdout.on('data', function(data) {\n      return logger.info(\"Hooks handler stdout:\", data.toString());\n    });\n    this.handler.stderr.on('data', function(data) {\n      return logger.info(\"Hooks handler stderr:\", data.toString());\n    });\n    this.handler.on('signalTerm', function() {\n      return logger.verbose('Gracefully terminating the hooks handler process');\n    });\n    this.handler.on('signalKill', function() {\n      return logger.verbose('Killing the hooks handler process');\n    });\n    this.handler.on('crash', (function(_this) {\n      return function(exitStatus, killed) {\n        var msg;\n        if (killed) {\n          msg = \"Hooks handler process '\" + _this.handlerCommand + \" \" + (handlerCommandArgs.join(' ')) + \"' was killed.\";\n        } else {\n          msg = \"Hooks handler process '\" + _this.handlerCommand + \" \" + (handlerCommandArgs.join(' ')) + \"' exited with status: \" + exitStatus;\n        }\n        logger.error(msg);\n        return _this.runner.hookHandlerError = new Error(msg);\n      };\n    })(this));\n    this.handler.on('error', (function(_this) {\n      return function(err) {\n        return _this.runner.hookHandlerError = err;\n      };\n    })(this));\n    return callback();\n  };\n\n  HooksWorkerClient.prototype.connectToHandler = function(callback) {\n    var connectAndSetupClient, start, timeout, waitForConnect;\n    start = Date.now();\n    waitForConnect = (function(_this) {\n      return function() {\n        var error, msg, timeout;\n        if ((Date.now() - start) < _this.connectTimeout) {\n          clearTimeout(timeout);\n          if (_this.connectError !== false) {\n            logger.warn('Error connecting to the hooks handler process. Is the handler running? Retrying.');\n            _this.connectError = false;\n          }\n          if (_this.clientConnected !== true) {\n            connectAndSetupClient();\n            return timeout = setTimeout(waitForConnect, _this.connectRetry);\n          }\n        } else {\n          clearTimeout(timeout);\n          if (!_this.clientConnected) {\n            if (_this.handlerClient != null) {\n              _this.handlerClient.destroy();\n            }\n            msg = (\"Connection timeout \" + (_this.connectTimeout / 1000) + \"s to hooks handler \") + (\"on \" + _this.handlerHost + \":\" + _this.handlerPort + \" exceeded. Try increasing the limit.\");\n            error = new Error(msg);\n            return callback(error);\n          }\n        }\n      };\n    })(this);\n    connectAndSetupClient = (function(_this) {\n      return function() {\n        var handlerBuffer;\n        logger.verbose('Starting TCP connection with hooks handler process.');\n        if (_this.runner.hookHandlerError != null) {\n          return callback(_this.runner.hookHandlerError);\n        }\n        _this.handlerClient = net.connect({\n          port: _this.handlerPort,\n          host: _this.handlerHost\n        });\n        _this.handlerClient.on('connect', function() {\n          logger.info(\"Successfully connected to hooks handler. Waiting \" + (_this.afterConnectWait / 1000) + \"s to start testing.\");\n          _this.clientConnected = true;\n          clearTimeout(timeout);\n          return setTimeout(callback, _this.afterConnectWait);\n        });\n        _this.handlerClient.on('close', function() {\n          return logger.debug('TCP communication with hooks handler closed.');\n        });\n        _this.handlerClient.on('error', function(connectError) {\n          logger.debug('TCP communication with hooks handler errored.', connectError);\n          return _this.connectError = connectError;\n        });\n        handlerBuffer = '';\n        return _this.handlerClient.on('data', function(data) {\n          var i, j, len, len1, message, messages, results, splittedData;\n          logger.debug('Dredd received some data from hooks handler.');\n          handlerBuffer += data.toString();\n          if (data.toString().indexOf(_this.handlerMessageDelimiter) > -1) {\n            splittedData = handlerBuffer.split(_this.handlerMessageDelimiter);\n            handlerBuffer = splittedData.pop();\n            messages = [];\n            for (i = 0, len = splittedData.length; i < len; i++) {\n              message = splittedData[i];\n              messages.push(JSON.parse(message));\n            }\n            results = [];\n            for (j = 0, len1 = messages.length; j < len1; j++) {\n              message = messages[j];\n              if (message.uuid != null) {\n                logger.verbose('Dredd received a valid message from hooks handler:', message.uuid);\n                results.push(_this.emitter.emit(message.uuid, message));\n              } else {\n                results.push(logger.verbose('UUID not present in hooks handler message, ignoring:', JSON.stringify(message, null, 2)));\n              }\n            }\n            return results;\n          }\n        });\n      };\n    })(this);\n    return timeout = setTimeout(waitForConnect, this.connectRetry);\n  };\n\n  HooksWorkerClient.prototype.registerHooks = function(callback) {\n    var eachHookNames, eventName, fn, i, len;\n    eachHookNames = ['beforeEach', 'beforeEachValidation', 'afterEach', 'beforeAll', 'afterAll'];\n    fn = (function(_this) {\n      return function(eventName) {\n        return _this.runner.hooks[eventName](function(data, hookCallback) {\n          var handleTimeout, message, messageHandler, timeout, uuid;\n          uuid = generateUuid();\n          message = {\n            event: eventName,\n            uuid: uuid,\n            data: data\n          };\n          logger.verbose('Sending HTTP transaction data to hooks handler:', uuid);\n          _this.handlerClient.write(JSON.stringify(message));\n          _this.handlerClient.write(_this.handlerMessageDelimiter);\n          messageHandler = function(receivedMessage) {\n            var index, j, key, len1, ref, ref1, value;\n            logger.verbose('Handling hook:', uuid);\n            clearTimeout(timeout);\n            if (eventName.indexOf('All') > -1) {\n              ref = receivedMessage.data;\n              for (index = j = 0, len1 = ref.length; j < len1; index = ++j) {\n                value = ref[index];\n                data[index] = value;\n              }\n            } else {\n              ref1 = receivedMessage.data;\n              for (key in ref1) {\n                if (!hasProp.call(ref1, key)) continue;\n                value = ref1[key];\n                data[key] = value;\n              }\n            }\n            return hookCallback();\n          };\n          handleTimeout = function() {\n            logger.warn('Hook handling timed out.');\n            if (eventName.indexOf('All') === -1) {\n              data.fail = 'Hook timed out.';\n            }\n            _this.emitter.removeListener(uuid, messageHandler);\n            return hookCallback();\n          };\n          timeout = setTimeout(handleTimeout, _this.timeout);\n          return _this.emitter.on(uuid, messageHandler);\n        });\n      };\n    })(this);\n    for (i = 0, len = eachHookNames.length; i < len; i++) {\n      eventName = eachHookNames[i];\n      fn(eventName);\n    }\n    this.runner.hooks.afterAll((function(_this) {\n      return function(transactions, hookCallback) {\n        var index, j, len1, modification, modifications, ref;\n        if (process.env.TEST_DREDD_HOOKS_HANDLER_ORDER === 'true') {\n          console.error('FOR TESTING ONLY');\n          modifications = ((ref = transactions[0]) != null ? ref.hooks_modifications : void 0) || [];\n          if (!modifications.length) {\n            throw new Error('Hooks must modify transaction.hooks_modifications');\n          }\n          for (index = j = 0, len1 = modifications.length; j < len1; index = ++j) {\n            modification = modifications[index];\n            console.error(index + \" \" + modification);\n          }\n          console.error('FOR TESTING ONLY');\n        }\n        return _this.stop(hookCallback);\n      };\n    })(this));\n    return callback();\n  };\n\n  return HooksWorkerClient;\n\n})();\n\nmodule.exports = HooksWorkerClient;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/child-process.js":"// Generated by CoffeeScript 1.12.5\nvar ASCII_CTRL_C, IS_WINDOWS, TERM_DEFAULT_RETRY_MS, TERM_DEFAULT_TIMEOUT_MS, TERM_FIRST_CHECK_TIMEOUT_MS, crossSpawn, signalKill, signalTerm, spawn, terminate,\n  slice = [].slice;\n\ncrossSpawn = require('cross-spawn');\n\nIS_WINDOWS = process.platform === 'win32';\n\nASCII_CTRL_C = 3;\n\nTERM_FIRST_CHECK_TIMEOUT_MS = 1;\n\nTERM_DEFAULT_TIMEOUT_MS = 1000;\n\nTERM_DEFAULT_RETRY_MS = 300;\n\nsignalKill = function(childProcess, callback) {\n  var taskkill;\n  childProcess.emit('signalKill');\n  if (IS_WINDOWS) {\n    taskkill = spawn('taskkill', ['/F', '/T', '/PID', childProcess.pid]);\n    return taskkill.on('exit', function(exitStatus) {\n      var err;\n      if (exitStatus) {\n        err = new Error(\"Unable to forcefully terminate process \" + childProcess.pid);\n        return callback(err);\n      }\n      return callback();\n    });\n  } else {\n    childProcess.kill('SIGKILL');\n    return process.nextTick(callback);\n  }\n};\n\nsignalTerm = function(childProcess, callback) {\n  childProcess.emit('signalTerm');\n  if (IS_WINDOWS) {\n    childProcess.stdin.write(String.fromCharCode(ASCII_CTRL_C));\n  } else {\n    childProcess.kill('SIGTERM');\n  }\n  return process.nextTick(callback);\n};\n\nterminate = function(childProcess, options, callback) {\n  var check, force, onExit, ref, retryDelay, start, t, terminated, timeout;\n  if (options == null) {\n    options = {};\n  }\n  if (typeof options === 'function') {\n    ref = [options, {}], callback = ref[0], options = ref[1];\n  }\n  force = options.force || false;\n  timeout = options.timeout != null ? options.timeout : TERM_DEFAULT_TIMEOUT_MS;\n  retryDelay = options.retryDelay != null ? options.retryDelay : TERM_DEFAULT_RETRY_MS;\n  terminated = false;\n  onExit = function() {\n    terminated = true;\n    return childProcess.removeListener('exit', onExit);\n  };\n  childProcess.on('exit', onExit);\n  start = Date.now();\n  t = void 0;\n  check = function() {\n    if (terminated) {\n      clearTimeout(t);\n      return callback();\n    } else {\n      if ((Date.now() - start) < timeout) {\n        return signalTerm(childProcess, function(err) {\n          if (err) {\n            return callback(err);\n          }\n          return t = setTimeout(check, retryDelay);\n        });\n      } else {\n        clearTimeout(t);\n        if (force) {\n          return signalKill(childProcess, callback);\n        } else {\n          return callback(new Error(\"Unable to gracefully terminate process \" + childProcess.pid));\n        }\n      }\n    }\n  };\n  return signalTerm(childProcess, function(err) {\n    if (err) {\n      return callback(err);\n    }\n    return t = setTimeout(check, TERM_FIRST_CHECK_TIMEOUT_MS);\n  });\n};\n\nspawn = function() {\n  var args, childProcess, killedIntentionally, terminatedIntentionally;\n  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n  childProcess = crossSpawn.spawn.apply(null, args);\n  childProcess.terminated = false;\n  killedIntentionally = false;\n  terminatedIntentionally = false;\n  childProcess.on('signalKill', function() {\n    return killedIntentionally = true;\n  });\n  childProcess.on('signalTerm', function() {\n    return terminatedIntentionally = true;\n  });\n  childProcess.signalKill = function() {\n    return signalKill(childProcess, function(err) {\n      if (err) {\n        return childProcess.emit('error', err);\n      }\n    });\n  };\n  childProcess.signalTerm = function() {\n    return signalTerm(childProcess, function(err) {\n      if (err) {\n        return childProcess.emit('error', err);\n      }\n    });\n  };\n  childProcess.terminate = function(options) {\n    return terminate(childProcess, options, function(err) {\n      if (err) {\n        return childProcess.emit('error', err);\n      }\n    });\n  };\n  childProcess.on('exit', function(exitStatus, signal) {\n    childProcess.terminated = true;\n    childProcess.killedIntentionally = killedIntentionally;\n    childProcess.terminatedIntentionally = terminatedIntentionally;\n    if (!killedIntentionally && !terminatedIntentionally) {\n      if (signal === 'SIGKILL') {\n        return childProcess.emit('crash', null, true);\n      } else if (exitStatus !== 0) {\n        return childProcess.emit('crash', exitStatus, false);\n      }\n    }\n  });\n  return childProcess;\n};\n\nmodule.exports = {\n  signalKill: signalKill,\n  signalTerm: signalTerm,\n  terminate: terminate,\n  spawn: spawn\n};\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/which.js":"// Generated by CoffeeScript 1.12.5\nvar which;\n\nwhich = require('which');\n\nmodule.exports = {\n  which: function(command) {\n    var e;\n    try {\n      which.sync(command);\n      return true;\n    } catch (error) {\n      e = error;\n      return false;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/blueprint-utils.js":"// Generated by CoffeeScript 1.12.5\nvar NEWLINE_RE, characterIndexToPosition, rangesToLinesText, sortNumbersAscending, warningLocationToRanges;\n\nNEWLINE_RE = /\\n/g;\n\ncharacterIndexToPosition = function(charIndex, code) {\n  var codeFragment, ref, row;\n  if (charIndex == null) {\n    charIndex = 0;\n  }\n  if (code == null) {\n    code = '';\n  }\n  codeFragment = code.substring(0, charIndex);\n  row = (((ref = codeFragment.match(NEWLINE_RE)) != null ? ref.length : void 0) || 0) + 1;\n  return {\n    row: row\n  };\n};\n\nsortNumbersAscending = function(a, b) {\n  return a - b;\n};\n\nwarningLocationToRanges = function(warningLocation, text) {\n  var i, j, lastLocation, len, len1, loc, locKey, position, range, ranges, rowIndex, rowsIndexes;\n  if (warningLocation == null) {\n    warningLocation = [];\n  }\n  if (text == null) {\n    text = '';\n  }\n  if (!warningLocation.length) {\n    return [];\n  }\n  rowsIndexes = [];\n  position = characterIndexToPosition(warningLocation[0][0], text);\n  rowsIndexes.push(position.row);\n  lastLocation = warningLocation[warningLocation.length - 1];\n  if (warningLocation.length > 0) {\n    for (locKey = i = 0, len = warningLocation.length; i < len; locKey = ++i) {\n      loc = warningLocation[locKey];\n      if (!(locKey > 0)) {\n        continue;\n      }\n      position = characterIndexToPosition(loc[0], text);\n      rowsIndexes.push(position.row);\n    }\n  }\n  rowsIndexes.sort(sortNumbersAscending);\n  ranges = [];\n  range = {\n    start: rowsIndexes[0],\n    end: rowsIndexes[0]\n  };\n  for (j = 0, len1 = rowsIndexes.length; j < len1; j++) {\n    rowIndex = rowsIndexes[j];\n    if (rowIndex === range.end || rowIndex === range.end + 1) {\n      range.end = rowIndex;\n    } else {\n      ranges.push(range);\n      range = {\n        start: rowIndex,\n        end: rowIndex\n      };\n    }\n  }\n  ranges.push(range);\n  return ranges;\n};\n\nrangesToLinesText = function(ranges) {\n  var i, len, pos, range, rangeIndex, ref;\n  pos = '';\n  ref = ranges || [];\n  for (rangeIndex = i = 0, len = ref.length; i < len; rangeIndex = ++i) {\n    range = ref[rangeIndex];\n    if (rangeIndex > 0) {\n      pos += ', ';\n    }\n    if (range.start !== range.end) {\n      pos += \"lines \" + range.start + \"-\" + range.end;\n    } else {\n      pos += \"line \" + range.start;\n    }\n  }\n  return pos;\n};\n\nmodule.exports = {\n  characterIndexToPosition: characterIndexToPosition,\n  sortNumbersAscending: sortNumbersAscending,\n  warningLocationToRanges: warningLocationToRanges,\n  rangesToLinesText: rangesToLinesText\n};\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/configuration.js":"// Generated by CoffeeScript 1.12.5\nvar EventEmitter, applyConfiguration, applyLoggingOptions, clone, coerceToArray, logger,\n  hasProp = {}.hasOwnProperty;\n\nEventEmitter = require('events').EventEmitter;\n\nclone = require('clone');\n\nlogger = require('./logger');\n\ncoerceToArray = function(value) {\n  if (Array.isArray(value)) {\n    return value;\n  } else if (typeof value === 'string') {\n    return [value];\n  } else if (value == null) {\n    return [];\n  } else {\n    return value;\n  }\n};\n\napplyLoggingOptions = function(options) {\n  if (options.color === 'false') {\n    options.color = false;\n  } else if (options.color === 'true') {\n    options.color = true;\n  }\n  logger.transports.console.colorize = options.color;\n  logger.transports.console.silent = options.silent;\n  logger.transports.console.timestamp = options.timestamp;\n  logger.transports.console.level = options.level;\n  return options;\n};\n\napplyConfiguration = function(config) {\n  var authHeader, configuration, customKey, customVal, key, method, ref, value;\n  configuration = {\n    blueprintPath: null,\n    server: null,\n    emitter: new EventEmitter,\n    hooksCode: null,\n    custom: {},\n    options: {\n      'dry-run': false,\n      silent: false,\n      reporter: null,\n      output: null,\n      debug: false,\n      header: null,\n      user: null,\n      'inline-errors': false,\n      details: false,\n      method: [],\n      only: [],\n      color: true,\n      level: 'info',\n      timestamp: false,\n      sorted: false,\n      names: false,\n      hookfiles: null,\n      sandbox: false,\n      language: 'nodejs',\n      'hooks-worker-timeout': 5000,\n      'hooks-worker-connect-timeout': 1500,\n      'hooks-worker-connect-retry': 500,\n      'hooks-worker-after-connect-wait': 100,\n      'hooks-worker-term-timeout': 5000,\n      'hooks-worker-term-retry': 500,\n      'hooks-worker-handler-host': '127.0.0.1',\n      'hooks-worker-handler-port': 61321\n    }\n  };\n  for (key in config) {\n    if (!hasProp.call(config, key)) continue;\n    value = config[key];\n    if (key !== 'custom') {\n      configuration[key] = value;\n    } else {\n      if (configuration['custom'] == null) {\n        configuration['custom'] = {};\n      }\n      ref = config['custom'] || {};\n      for (customKey in ref) {\n        if (!hasProp.call(ref, customKey)) continue;\n        customVal = ref[customKey];\n        configuration['custom'][customKey] = clone(customVal, false);\n      }\n    }\n  }\n  configuration.options.reporter = coerceToArray(configuration.options.reporter);\n  configuration.options.output = coerceToArray(configuration.options.output);\n  configuration.options.header = coerceToArray(configuration.options.header);\n  configuration.options.method = coerceToArray(configuration.options.method);\n  configuration.options.only = coerceToArray(configuration.options.only);\n  configuration.options.path = coerceToArray(configuration.options.path);\n  if (config.blueprintPath) {\n    configuration.options.path.push(config.blueprintPath);\n  }\n  configuration.options.method = (function() {\n    var i, len, ref1, results;\n    ref1 = configuration.options.method;\n    results = [];\n    for (i = 0, len = ref1.length; i < len; i++) {\n      method = ref1[i];\n      results.push(method.toUpperCase());\n    }\n    return results;\n  })();\n  if (configuration.options.user != null) {\n    authHeader = 'Authorization:Basic ' + new Buffer(configuration.options.user).toString('base64');\n    configuration.options.header.push(authHeader);\n  }\n  configuration.options = applyLoggingOptions(configuration.options);\n  return configuration;\n};\n\nmodule.exports = {\n  applyLoggingOptions: applyLoggingOptions,\n  applyConfiguration: applyConfiguration\n};\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/configure-reporters.js":"// Generated by CoffeeScript 1.12.5\nvar ApiaryReporter, BaseReporter, CliReporter, DotReporter, HtmlReporter, MarkdownReporter, NyanCatReporter, XUnitReporter, cliReporters, configureReporters, fileReporters, intersection, logger,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nBaseReporter = require('./reporters/base-reporter');\n\nXUnitReporter = require('./reporters/x-unit-reporter');\n\nCliReporter = require('./reporters/cli-reporter');\n\nDotReporter = require('./reporters/dot-reporter');\n\nNyanCatReporter = require('./reporters/nyan-reporter');\n\nHtmlReporter = require('./reporters/html-reporter');\n\nMarkdownReporter = require('./reporters/markdown-reporter');\n\nApiaryReporter = require('./reporters/apiary-reporter');\n\nlogger = require('./logger');\n\nfileReporters = ['junit', 'html', 'markdown', 'apiary'];\n\ncliReporters = ['dot', 'nyan'];\n\nintersection = function(a, b) {\n  var j, len, ref, results, value;\n  if (a.length > b.length) {\n    ref = [b, a], a = ref[0], b = ref[1];\n  }\n  results = [];\n  for (j = 0, len = a.length; j < len; j++) {\n    value = a[j];\n    if (indexOf.call(b, value) >= 0) {\n      results.push(value);\n    }\n  }\n  return results;\n};\n\nconfigureReporters = function(config, stats, tests, runner) {\n  var addCli, addReporter, baseReporter, i, j, len, outputs, path, reporter, reporters, results, usedFileReporters, usedFileReportersLength;\n  baseReporter = new BaseReporter(config.emitter, stats, tests);\n  reporters = config.options.reporter;\n  outputs = config.options.output;\n  logger.verbose('Configuring reporters:', reporters, outputs);\n  addCli = function(reporters) {\n    var cliReporter, usedCliReporters;\n    if (reporters.length > 0) {\n      usedCliReporters = intersection(reporters, cliReporters);\n      if (usedCliReporters.length === 0) {\n        return cliReporter = new CliReporter(config.emitter, stats, tests, config.options['inline-errors'], config.options.details);\n      } else {\n        return addReporter(usedCliReporters[0], config.emitter, stats, tests);\n      }\n    } else {\n      return cliReporter = new CliReporter(config.emitter, stats, tests, config.options['inline-errors'], config.options.details);\n    }\n  };\n  addReporter = function(reporter, emitter, stats, tests, path) {\n    var apiaryReporter, dotReporter, htmlReporter, mdReporter, nyanCatReporter, xUnitReporter;\n    switch (reporter) {\n      case 'junit':\n        return xUnitReporter = new XUnitReporter(emitter, stats, tests, path, config.options.details);\n      case 'dot':\n        return dotReporter = new DotReporter(emitter, stats, tests);\n      case 'nyan':\n        return nyanCatReporter = new NyanCatReporter(emitter, stats, tests);\n      case 'html':\n        return htmlReporter = new HtmlReporter(emitter, stats, tests, path, config.options.details);\n      case 'markdown':\n        return mdReporter = new MarkdownReporter(emitter, stats, tests, path, config.options.details);\n      case 'apiary':\n        return apiaryReporter = new ApiaryReporter(emitter, stats, tests, config, runner);\n    }\n  };\n  if (!config.options.silent) {\n    addCli(reporters);\n  }\n  usedFileReporters = intersection(reporters, fileReporters);\n  stats.fileBasedReporters = usedFileReporters.length;\n  if (usedFileReporters.length > 0) {\n    usedFileReportersLength = usedFileReporters.length;\n    if (reporters.indexOf('apiary') > -1) {\n      usedFileReportersLength = usedFileReportersLength - 1;\n    }\n    if (usedFileReportersLength > outputs.length) {\n      logger.warn('There are more reporters requiring output paths than there are output paths provided. Using default paths for additional file-based reporters.');\n    }\n    results = [];\n    for (i = j = 0, len = usedFileReporters.length; j < len; i = ++j) {\n      reporter = usedFileReporters[i];\n      path = outputs[i] ? outputs[i] : null;\n      results.push(addReporter(reporter, config.emitter, stats, tests, path));\n    }\n    return results;\n  }\n};\n\nmodule.exports = configureReporters;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/base-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar BaseReporter, logger,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nlogger = require('./../logger');\n\nBaseReporter = (function() {\n  function BaseReporter(emitter, stats, tests) {\n    this.configureEmitter = bind(this.configureEmitter, this);\n    this.type = \"base\";\n    this.stats = stats;\n    this.tests = tests;\n    this.configureEmitter(emitter);\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n  }\n\n  BaseReporter.prototype.configureEmitter = function(emitter) {\n    emitter.on('start', (function(_this) {\n      return function(rawBlueprint, callback) {\n        _this.stats.start = new Date();\n        return callback();\n      };\n    })(this));\n    emitter.on('end', (function(_this) {\n      return function(callback) {\n        _this.stats.end = new Date();\n        _this.stats.duration = _this.stats.end - _this.stats.start;\n        return callback();\n      };\n    })(this));\n    emitter.on('test start', (function(_this) {\n      return function(test) {\n        _this.tests.push(test);\n        _this.stats.tests += 1;\n        return test['start'] = new Date();\n      };\n    })(this));\n    emitter.on('test pass', (function(_this) {\n      return function(test) {\n        _this.stats.passes += 1;\n        test['end'] = new Date();\n        return test['duration'] = test.end - test.start;\n      };\n    })(this));\n    emitter.on('test skip', (function(_this) {\n      return function(test) {\n        return _this.stats.skipped += 1;\n      };\n    })(this));\n    emitter.on('test fail', (function(_this) {\n      return function(test) {\n        _this.stats.failures += 1;\n        test['end'] = new Date();\n        return test['duration'] = test.end - test.start;\n      };\n    })(this));\n    return emitter.on('test error', (function(_this) {\n      return function(error, test) {\n        _this.stats.errors += 1;\n        test['end'] = new Date();\n        return test['duration'] = test.end - test.start;\n      };\n    })(this));\n  };\n\n  return BaseReporter;\n\n})();\n\nmodule.exports = BaseReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/x-unit-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar EventEmitter, XUnitReporter, file, fs, htmlencode, logger, prettifyResponse,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nEventEmitter = require('events').EventEmitter;\n\nfs = require('fs');\n\nhtmlencode = require('htmlencode');\n\nfile = require('file');\n\nlogger = require('./../logger');\n\nprettifyResponse = require('./../prettify-response');\n\nXUnitReporter = (function(superClass) {\n  var appendLine, cdata, toTag, updateSuiteStats;\n\n  extend(XUnitReporter, superClass);\n\n  function XUnitReporter(emitter, stats, tests, path, details) {\n    this.configureEmitter = bind(this.configureEmitter, this);\n    XUnitReporter.__super__.constructor.call(this);\n    this.type = 'xunit';\n    this.stats = stats;\n    this.tests = tests;\n    this.path = this.sanitizedPath(path);\n    this.details = details;\n    this.configureEmitter(emitter);\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n  }\n\n  XUnitReporter.prototype.sanitizedPath = function(path) {\n    var filePath;\n    filePath = path != null ? file.path.abspath(path) : file.path.abspath(\"./report.xml\");\n    if (fs.existsSync(filePath)) {\n      logger.info(\"File exists at \" + filePath + \", will be overwritten...\");\n      fs.unlinkSync(filePath);\n    }\n    return filePath;\n  };\n\n  XUnitReporter.prototype.configureEmitter = function(emitter) {\n    emitter.on('start', (function(_this) {\n      return function(rawBlueprint, callback) {\n        appendLine(_this.path, toTag('testsuite', {\n          name: 'Dredd Tests',\n          tests: _this.stats.tests,\n          failures: _this.stats.failures,\n          errors: _this.stats.errors,\n          skip: _this.stats.skipped,\n          timestamp: (new Date()).toUTCString(),\n          time: _this.stats.duration / 1000\n        }, false));\n        return callback();\n      };\n    })(this));\n    emitter.on('end', (function(_this) {\n      return function(callback) {\n        return updateSuiteStats(_this.path, _this.stats, callback);\n      };\n    })(this));\n    emitter.on('test pass', (function(_this) {\n      return function(test) {\n        var attrs, deets;\n        attrs = {\n          name: htmlencode.htmlEncode(test.title),\n          time: test.duration / 1000\n        };\n        if (_this.details) {\n          deets = \"\\nRequest:\\n\" + (prettifyResponse(test.request)) + \"\\nExpected:\\n\" + (prettifyResponse(test.expected)) + \"\\nActual:\\n\" + (prettifyResponse(test.actual));\n          return appendLine(_this.path, toTag('testcase', attrs, false, toTag('system-out', null, false, cdata(deets))));\n        } else {\n          return appendLine(_this.path, toTag('testcase', attrs, true));\n        }\n      };\n    })(this));\n    emitter.on('test skip', (function(_this) {\n      return function(test) {\n        var attrs;\n        attrs = {\n          name: htmlencode.htmlEncode(test.title),\n          time: test.duration / 1000\n        };\n        return appendLine(_this.path, toTag('testcase', attrs, false, toTag('skipped', null, true)));\n      };\n    })(this));\n    emitter.on('test fail', (function(_this) {\n      return function(test) {\n        var attrs, diff;\n        attrs = {\n          name: htmlencode.htmlEncode(test.title),\n          time: test.duration / 1000\n        };\n        diff = \"Message:\\n\" + test.message + \"\\nRequest:\\n\" + (prettifyResponse(test.request)) + \"\\nExpected:\\n\" + (prettifyResponse(test.expected)) + \"\\nActual:\\n\" + (prettifyResponse(test.actual));\n        return appendLine(_this.path, toTag('testcase', attrs, false, toTag('failure', null, false, cdata(diff))));\n      };\n    })(this));\n    return emitter.on('test error', (function(_this) {\n      return function(error, test) {\n        var attrs, errorMessage;\n        attrs = {\n          name: htmlencode.htmlEncode(test.title),\n          time: test.duration / 1000\n        };\n        errorMessage = \"\\nError: \\n\" + error + \"\\nStacktrace: \\n\" + error.stack;\n        return appendLine(_this.path, toTag('testcase', attrs, false, toTag('failure', null, false, cdata(errorMessage))));\n      };\n    })(this));\n  };\n\n  updateSuiteStats = function(path, stats, callback) {\n    return fs.readFile(path, function(err, data) {\n      var newStats, position, restOfFile, xmlHeader;\n      if (!err) {\n        data = data.toString();\n        position = data.toString().indexOf('\\n');\n        if (position !== -1) {\n          restOfFile = data.substr(position + 1);\n          newStats = toTag('testsuite', {\n            name: 'Dredd Tests',\n            tests: stats.tests,\n            failures: stats.failures,\n            errors: stats.errors,\n            skip: stats.skipped,\n            timestamp: (new Date()).toUTCString(),\n            time: stats.duration / 1000\n          }, false);\n          xmlHeader = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n          return fs.writeFile(path, xmlHeader + '\\n' + newStats + '\\n' + restOfFile + '</testsuite>', function(err) {\n            if (err) {\n              logger.error(err);\n            }\n            return callback();\n          });\n        } else {\n          return callback();\n        }\n      } else {\n        logger.error(err);\n        return callback();\n      }\n    });\n  };\n\n  cdata = function(str) {\n    return '<![CDATA[' + str + ']]>';\n  };\n\n  appendLine = function(path, line) {\n    return fs.appendFileSync(path, line + \"\\n\");\n  };\n\n  toTag = function(name, attrs, close, content) {\n    var end, key, pairs, tag;\n    end = (close ? \"/>\" : \">\");\n    pairs = [];\n    tag = void 0;\n    for (key in attrs) {\n      pairs.push(key + \"=\\\"\" + attrs[key] + \"\\\"\");\n    }\n    tag = \"<\" + name + (pairs.length ? \" \" + pairs.join(\" \") : \"\") + end;\n    if (content) {\n      tag += content + \"</\" + name + end;\n    }\n    return tag;\n  };\n\n  return XUnitReporter;\n\n})(EventEmitter);\n\nmodule.exports = XUnitReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/prettify-response.js":"// Generated by CoffeeScript 1.12.5\nvar html, logger, prettifyResponse,\n  hasProp = {}.hasOwnProperty;\n\nhtml = require('html');\n\nlogger = require('./logger');\n\nprettifyResponse = function(response) {\n  var contentType, header, hkey, hval, key, prettifyBody, stringRepresentation, stringify, value;\n  stringify = function(obj) {\n    var e;\n    try {\n      if (typeof obj === 'string') {\n        obj = JSON.parse(obj);\n      }\n      obj = JSON.stringify(obj, null, 2);\n    } catch (error) {\n      e = error;\n      logger.debug(\"Could not stringify: \" + obj);\n    }\n    return obj;\n  };\n  prettifyBody = function(body, contentType) {\n    switch (contentType) {\n      case 'application/json':\n        body = stringify(body);\n        break;\n      case 'text/html':\n        body = html.prettyPrint(body, {\n          indent_size: 2\n        });\n    }\n    return body;\n  };\n  if ((response != null ? response.headers : void 0) != null) {\n    contentType = (response != null ? response.headers['content-type'] : void 0) || (response != null ? response.headers['Content-Type'] : void 0);\n  }\n  stringRepresentation = \"\";\n  for (key in response) {\n    if (!hasProp.call(response, key)) continue;\n    value = response[key];\n    if (key === 'body') {\n      value = '\\n' + prettifyBody(value, contentType);\n    } else if (key === 'schema') {\n      value = '\\n' + stringify(value);\n    } else if (key === 'headers') {\n      header = '\\n';\n      for (hkey in value) {\n        if (!hasProp.call(value, hkey)) continue;\n        hval = value[hkey];\n        header += \"    \" + hkey + \": \" + hval + \"\\n\";\n      }\n      value = header;\n    }\n    stringRepresentation += key + \": \" + value + \"\\n\";\n  }\n  return stringRepresentation;\n};\n\nmodule.exports = prettifyResponse;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/cli-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar CliReporter, logger, prettifyResponse,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nlogger = require('./../logger');\n\nprettifyResponse = require('./../prettify-response');\n\nCliReporter = (function() {\n  function CliReporter(emitter, stats, tests, inlineErrors, details) {\n    this.configureEmitter = bind(this.configureEmitter, this);\n    this.type = 'cli';\n    this.stats = stats;\n    this.tests = tests;\n    this.configureEmitter(emitter);\n    this.inlineErrors = inlineErrors;\n    this.details = details;\n    this.errors = [];\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n  }\n\n  CliReporter.prototype.configureEmitter = function(emitter) {\n    emitter.on('start', function(rawBlueprint, callback) {\n      logger.info('Beginning Dredd testing...');\n      return callback();\n    });\n    emitter.on('end', (function(_this) {\n      return function(callback) {\n        var i, len, ref, test;\n        if (!_this.inlineErrors) {\n          if (_this.errors.length !== 0) {\n            logger.info(\"Displaying failed tests...\");\n          }\n          ref = _this.errors;\n          for (i = 0, len = ref.length; i < len; i++) {\n            test = ref[i];\n            logger.fail(test.title + (\" duration: \" + test.duration + \"ms\"));\n            logger.fail(test.message);\n            if (test.request) {\n              logger.request(\"\\n\" + prettifyResponse(test.request) + \"\\n\");\n            }\n            if (test.expected) {\n              logger.expected(\"\\n\" + prettifyResponse(test.expected) + \"\\n\");\n            }\n            if (test.actual) {\n              logger.actual(\"\\n\" + prettifyResponse(test.actual) + \"\\n\\n\");\n            }\n          }\n        }\n        if (_this.stats.tests > 0) {\n          logger.complete((_this.stats.passes + \" passing, \") + (_this.stats.failures + \" failing, \") + (_this.stats.errors + \" errors, \") + (_this.stats.skipped + \" skipped, \") + (_this.stats.tests + \" total\"));\n        }\n        logger.complete(\"Tests took \" + _this.stats.duration + \"ms\");\n        return callback();\n      };\n    })(this));\n    emitter.on('test pass', (function(_this) {\n      return function(test) {\n        logger.pass(test.title + (\" duration: \" + test.duration + \"ms\"));\n        if (_this.details) {\n          logger.request(\"\\n\" + prettifyResponse(test.request) + \"\\n\");\n          logger.expected(\"\\n\" + prettifyResponse(test.expected) + \"\\n\");\n          return logger.actual(\"\\n\" + prettifyResponse(test.actual) + \"\\n\\n\");\n        }\n      };\n    })(this));\n    emitter.on('test skip', function(test) {\n      return logger.skip(test.title);\n    });\n    emitter.on('test fail', (function(_this) {\n      return function(test) {\n        logger.fail(test.title + (\" duration: \" + test.duration + \"ms\"));\n        if (_this.inlineErrors) {\n          logger.fail(test.message);\n          if (test.request) {\n            logger.request(\"\\n\" + prettifyResponse(test.request) + \"\\n\");\n          }\n          if (test.expected) {\n            logger.expected(\"\\n\" + prettifyResponse(test.expected) + \"\\n\");\n          }\n          if (test.actual) {\n            return logger.actual(\"\\n\" + prettifyResponse(test.actual) + \"\\n\\n\");\n          }\n        } else {\n          return _this.errors.push(test);\n        }\n      };\n    })(this));\n    return emitter.on('test error', (function(_this) {\n      return function(error, test) {\n        var connectionErrors;\n        connectionErrors = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE'];\n        if (connectionErrors.indexOf(error.code) > -1) {\n          test.message = \"Error connecting to server under test!\";\n        }\n        if (!_this.inlineErrors) {\n          _this.errors.push(test);\n        }\n        logger.error(test.title + (\" duration: \" + test.duration + \"ms\"));\n        if (connectionErrors.indexOf(error.code) > -1) {\n          return logger.error(test.message);\n        } else {\n          return logger.error(error.stack);\n        }\n      };\n    })(this));\n  };\n\n  return CliReporter;\n\n})();\n\nmodule.exports = CliReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/dot-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar DotReporter, logger, prettifyResponse;\n\nlogger = require('../logger');\n\nprettifyResponse = require('../prettify-response');\n\nDotReporter = (function() {\n  function DotReporter(emitter, stats, tests) {\n    this.type = 'dot';\n    this.stats = stats;\n    this.tests = tests;\n    this.configureEmitter(emitter);\n    this.errors = [];\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n  }\n\n  DotReporter.prototype.configureEmitter = function(emitter) {\n    emitter.on('start', function(rawBlueprint, callback) {\n      logger.info('Beginning Dredd testing...');\n      return callback();\n    });\n    emitter.on('end', (function(_this) {\n      return function(callback) {\n        var i, len, ref, test;\n        if (_this.stats.tests > 0) {\n          if (_this.errors.length > 0) {\n            _this.write('\\n');\n            logger.info('Displaying failed tests...');\n            ref = _this.errors;\n            for (i = 0, len = ref.length; i < len; i++) {\n              test = ref[i];\n              logger.fail(test.title + (\" duration: \" + test.duration + \"ms\"));\n              logger.fail(test.message);\n              logger.request(\"\\n\" + prettifyResponse(test.request) + \"\\n\");\n              logger.expected(\"\\n\" + prettifyResponse(test.expected) + \"\\n\");\n              logger.actual(\"\\n\" + prettifyResponse(test.actual) + \"\\n\\n\");\n            }\n          }\n          _this.write('\\n');\n          logger.complete(_this.stats.passes + \" passing, \" + _this.stats.failures + \" failing, \" + _this.stats.errors + \" errors, \" + _this.stats.skipped + \" skipped\");\n          logger.complete(\"Tests took \" + _this.stats.duration + \"ms\");\n          return callback();\n        }\n      };\n    })(this));\n    emitter.on('test pass', (function(_this) {\n      return function(test) {\n        return _this.write('.');\n      };\n    })(this));\n    emitter.on('test skip', (function(_this) {\n      return function(test) {\n        return _this.write('-');\n      };\n    })(this));\n    emitter.on('test fail', (function(_this) {\n      return function(test) {\n        _this.write('F');\n        return _this.errors.push(test);\n      };\n    })(this));\n    return emitter.on('test error', (function(_this) {\n      return function(error, test) {\n        _this.write('E');\n        test.message = \"\\nError: \\n\" + error + \"\\nStacktrace: \\n\" + error.stack + \"\\n\";\n        return _this.errors.push(test);\n      };\n    })(this));\n  };\n\n  DotReporter.prototype.write = function(str) {\n    return process.stdout.write(str);\n  };\n\n  return DotReporter;\n\n})();\n\nmodule.exports = DotReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/nyan-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar NyanCatReporter, logger, prettifyResponse, tty,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\ntty = require('tty');\n\nlogger = require('./../logger');\n\nprettifyResponse = require('./../prettify-response');\n\nNyanCatReporter = (function() {\n  function NyanCatReporter(emitter, stats, tests) {\n    this.rainbowify = bind(this.rainbowify, this);\n    this.cursorHide = bind(this.cursorHide, this);\n    this.cursorShow = bind(this.cursorShow, this);\n    this.cursorDown = bind(this.cursorDown, this);\n    this.cursorUp = bind(this.cursorUp, this);\n    this.face = bind(this.face, this);\n    this.drawNyanCat = bind(this.drawNyanCat, this);\n    this.drawRainbow = bind(this.drawRainbow, this);\n    this.appendRainbow = bind(this.appendRainbow, this);\n    this.drawScoreboard = bind(this.drawScoreboard, this);\n    this.draw = bind(this.draw, this);\n    this.configureEmitter = bind(this.configureEmitter, this);\n    var width, windowWidth;\n    this.type = 'nyan';\n    this.stats = stats;\n    this.tests = tests;\n    this.isatty = tty.isatty(1) && tty.isatty(2);\n    if (this.isatty) {\n      if (process.stdout.getWindowSize) {\n        windowWidth = process.stdout.getWindowSize(1)[0];\n      } else {\n        windowWidth = tty.getWindowSize()[1];\n      }\n    } else {\n      windowWidth = 75;\n    }\n    width = windowWidth * .75 | 0;\n    this.rainbowColors = this.generateColors();\n    this.colorIndex = 0;\n    this.numberOfLines = 4;\n    this.trajectories = [[], [], [], []];\n    this.nyanCatWidth = 11;\n    this.trajectoryWidthMax = width - this.nyanCatWidth;\n    this.scoreboardWidth = 5;\n    this.tick = 0;\n    this.errors = [];\n    this.configureEmitter(emitter);\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n  }\n\n  NyanCatReporter.prototype.configureEmitter = function(emitter) {\n    emitter.on('start', (function(_this) {\n      return function(rawBlueprint, callback) {\n        _this.cursorHide();\n        _this.draw();\n        return callback();\n      };\n    })(this));\n    emitter.on('end', (function(_this) {\n      return function(callback) {\n        var i, j, len, ref, test;\n        _this.cursorShow();\n        i = 0;\n        while (i < _this.numberOfLines) {\n          _this.write(\"\\n\");\n          i++;\n        }\n        if (_this.errors.length > 0) {\n          _this.write(\"\\n\");\n          logger.info(\"Displaying failed tests...\");\n          ref = _this.errors;\n          for (j = 0, len = ref.length; j < len; j++) {\n            test = ref[j];\n            logger.fail(test.title + (\" duration: \" + test.duration + \"ms\"));\n            logger.fail(test.message);\n            logger.request(\"\\n\" + prettifyResponse(test.request) + \"\\n\");\n            logger.expected(\"\\n\" + prettifyResponse(test.expected) + \"\\n\");\n            logger.actual(\"\\n\" + prettifyResponse(test.actual) + \"\\n\\n\");\n          }\n        }\n        logger.complete(_this.stats.passes + \" passing, \" + _this.stats.failures + \" failing, \" + _this.stats.errors + \" errors, \" + _this.stats.skipped + \" skipped\");\n        logger.complete(\"Tests took \" + _this.stats.duration + \"ms\");\n        return callback();\n      };\n    })(this));\n    emitter.on('test pass', (function(_this) {\n      return function(test) {\n        return _this.draw();\n      };\n    })(this));\n    emitter.on('test skip', (function(_this) {\n      return function(test) {\n        return _this.draw();\n      };\n    })(this));\n    emitter.on('test fail', (function(_this) {\n      return function(test) {\n        _this.errors.push(test);\n        return _this.draw();\n      };\n    })(this));\n    return emitter.on('test error', (function(_this) {\n      return function(error, test) {\n        test.message = \"\\nError: \\n\" + error + \"\\nStacktrace: \\n\" + error.stack + \"\\n\";\n        _this.errors.push(test);\n        return _this.draw();\n      };\n    })(this));\n  };\n\n  NyanCatReporter.prototype.draw = function() {\n    this.appendRainbow();\n    this.drawScoreboard();\n    this.drawRainbow();\n    this.drawNyanCat();\n    return this.tick = !this.tick;\n  };\n\n  NyanCatReporter.prototype.drawScoreboard = function() {\n    var colors, draw, stats, write;\n    write = this.write;\n    draw = function(color, n) {\n      write(\" \");\n      write(\"\\u001b[\" + color + \"m\" + n + \"\\u001b[0m\");\n      return write(\"\\n\");\n    };\n    stats = this.stats;\n    colors = {\n      fail: 31,\n      skipped: 36,\n      pass: 32\n    };\n    draw(colors.pass, this.stats.passes);\n    draw(colors.fail, this.stats.failures);\n    draw(colors.fail, this.stats.errors);\n    draw(colors.skipped, this.stats.skipped);\n    this.write(\"\\n\");\n    return this.cursorUp(this.numberOfLines + 1);\n  };\n\n  NyanCatReporter.prototype.appendRainbow = function() {\n    var index, rainbowified, results, segment, trajectory;\n    segment = (this.tick ? \"_\" : \"-\");\n    rainbowified = this.rainbowify(segment);\n    index = 0;\n    results = [];\n    while (index < this.numberOfLines) {\n      trajectory = this.trajectories[index];\n      if (trajectory.length >= this.trajectoryWidthMax) {\n        trajectory.shift();\n      }\n      trajectory.push(rainbowified);\n      results.push(index++);\n    }\n    return results;\n  };\n\n  NyanCatReporter.prototype.drawRainbow = function() {\n    var scoreboardWidth, write;\n    scoreboardWidth = this.scoreboardWidth;\n    write = this.write;\n    this.trajectories.forEach(function(line, index) {\n      write(\"\\u001b[\" + scoreboardWidth + \"C\");\n      write(line.join(\"\"));\n      return write(\"\\n\");\n    });\n    return this.cursorUp(this.numberOfLines);\n  };\n\n  NyanCatReporter.prototype.drawNyanCat = function() {\n    var color, face, padding, startWidth, tail;\n    startWidth = this.scoreboardWidth + this.trajectories[0].length;\n    color = \"\\u001b[\" + startWidth + \"C\";\n    padding = \"\";\n    this.write(color);\n    this.write(\"_,------,\");\n    this.write(\"\\n\");\n    this.write(color);\n    padding = (this.tick ? \"  \" : \"   \");\n    this.write(\"_|\" + padding + \"/\\\\_/\\\\ \");\n    this.write(\"\\n\");\n    this.write(color);\n    padding = (this.tick ? \"_\" : \"__\");\n    tail = (this.tick ? \"~\" : \"^\");\n    face = void 0;\n    this.write(tail + \"|\" + padding + this.face() + \" \");\n    this.write(\"\\n\");\n    this.write(color);\n    padding = (this.tick ? \" \" : \"  \");\n    this.write(padding + \"\\\"\\\"  \\\"\\\" \");\n    this.write(\"\\n\");\n    return this.cursorUp(this.numberOfLines);\n  };\n\n  NyanCatReporter.prototype.face = function() {\n    var stats;\n    stats = this.stats;\n    if (stats.failures) {\n      return \"( x .x)\";\n    } else if (stats.skipped) {\n      return \"( o .o)\";\n    } else if (stats.passes) {\n      return \"( ^ .^)\";\n    } else {\n      return \"( - .-)\";\n    }\n  };\n\n  NyanCatReporter.prototype.cursorUp = function(n) {\n    return this.write(\"\\u001b[\" + n + \"A\");\n  };\n\n  NyanCatReporter.prototype.cursorDown = function(n) {\n    return this.write(\"\\u001b[\" + n + \"B\");\n  };\n\n  NyanCatReporter.prototype.cursorShow = function() {\n    return this.isatty && this.write('\\u001b[?25h');\n  };\n\n  NyanCatReporter.prototype.cursorHide = function() {\n    return this.isatty && this.write('\\u001b[?25l');\n  };\n\n  NyanCatReporter.prototype.generateColors = function() {\n    var b, colors, g, i, n, pi3, r;\n    colors = [];\n    i = 0;\n    while (i < (6 * 7)) {\n      pi3 = Math.floor(Math.PI / 3);\n      n = i * (1.0 / 6);\n      r = Math.floor(3 * Math.sin(n) + 3);\n      g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n      b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n      colors.push(36 * r + 6 * g + b + 16);\n      i++;\n    }\n    return colors;\n  };\n\n  NyanCatReporter.prototype.rainbowify = function(str) {\n    var color;\n    color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n    this.colorIndex += 1;\n    return \"\\u001b[38;5;\" + color + \"m\" + str + \"\\u001b[0m\";\n  };\n\n  NyanCatReporter.prototype.write = function(str) {\n    return process.stdout.write(str);\n  };\n\n  return NyanCatReporter;\n\n})();\n\nmodule.exports = NyanCatReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/html-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar EventEmitter, HtmlReporter, file, fs, logger, md, prettifyResponse,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nEventEmitter = require('events').EventEmitter;\n\nfs = require('fs');\n\nmd = require('markdown-it')();\n\nfile = require('file');\n\nlogger = require('./../logger');\n\nprettifyResponse = require('./../prettify-response');\n\nHtmlReporter = (function(superClass) {\n  extend(HtmlReporter, superClass);\n\n  function HtmlReporter(emitter, stats, tests, path, details) {\n    HtmlReporter.__super__.constructor.call(this);\n    this.type = 'html';\n    this.stats = stats;\n    this.tests = tests;\n    this.path = this.sanitizedPath(path);\n    this.buf = '';\n    this.level = 1;\n    this.details = details;\n    this.configureEmitter(emitter);\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n  }\n\n  HtmlReporter.prototype.sanitizedPath = function(path) {\n    var filePath;\n    filePath = path != null ? file.path.abspath(path) : file.path.abspath(\"./report.html\");\n    if (fs.existsSync(filePath)) {\n      logger.info(\"File exists at \" + filePath + \", will be overwritten...\");\n    }\n    return filePath;\n  };\n\n  HtmlReporter.prototype.configureEmitter = function(emitter) {\n    var title;\n    title = (function(_this) {\n      return function(str) {\n        return Array(_this.level).join(\"#\") + \" \" + str;\n      };\n    })(this);\n    emitter.on('start', (function(_this) {\n      return function(rawBlueprint, callback) {\n        _this.level++;\n        _this.buf += title('Dredd Tests') + \"\\n\";\n        return callback();\n      };\n    })(this));\n    emitter.on('end', (function(_this) {\n      return function(callback) {\n        var html;\n        html = md.render(_this.buf);\n        return fs.writeFile(_this.path, html, function(err) {\n          if (err) {\n            logger.error(err);\n          }\n          return callback();\n        });\n      };\n    })(this));\n    emitter.on('test start', (function(_this) {\n      return function(test) {\n        return _this.level++;\n      };\n    })(this));\n    emitter.on('test pass', (function(_this) {\n      return function(test) {\n        _this.buf += title(\"Pass: \" + test.title) + \"\\n\";\n        if (_this.details) {\n          _this.level++;\n          _this.buf += title(\"Request\") + \"\\n```\\n\" + prettifyResponse(test.request) + \"\\n```\\n\\n\";\n          _this.buf += title(\"Expected\") + \"\\n```\\n\" + prettifyResponse(test.expected) + \"\\n```\\n\\n\";\n          _this.buf += title(\"Actual\") + \"\\n```\\n\" + prettifyResponse(test.actual) + \"\\n```\\n\\n\";\n          _this.level--;\n        }\n        return _this.level--;\n      };\n    })(this));\n    emitter.on('test skip', (function(_this) {\n      return function(test) {\n        _this.buf += title(\"Skip: \" + test.title) + \"\\n\";\n        return _this.level--;\n      };\n    })(this));\n    emitter.on('test fail', (function(_this) {\n      return function(test) {\n        _this.buf += title(\"Fail: \" + test.title + \"\\n\");\n        _this.level++;\n        _this.buf += title(\"Message\") + \"\\n```\\n\" + test.message + \"\\n```\\n\\n\";\n        _this.buf += title(\"Request\") + \"\\n```\\n\" + prettifyResponse(test.request) + \"\\n```\\n\\n\";\n        _this.buf += title(\"Expected\") + \"\\n```\\n\" + prettifyResponse(test.expected) + \"\\n```\\n\\n\";\n        _this.buf += title(\"Actual\") + \"\\n```\\n\" + prettifyResponse(test.actual) + \"\\n```\\n\\n\";\n        _this.level--;\n        return _this.level--;\n      };\n    })(this));\n    return emitter.on('test error', (function(_this) {\n      return function(error, test) {\n        _this.buf += title(\"Error: \" + test.title + \"\\n\");\n        _this.buf += \"\\n```\\n\";\n        _this.buf += \"\\nError: \\n\" + error + \"\\nStacktrace: \\n\" + error.stack + \"\\n\";\n        _this.buf += \"```\\n\\n\";\n        return _this.level--;\n      };\n    })(this));\n  };\n\n  return HtmlReporter;\n\n})(EventEmitter);\n\nmodule.exports = HtmlReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/markdown-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar EventEmitter, MarkdownReporter, file, fs, logger, prettifyResponse,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nEventEmitter = require('events').EventEmitter;\n\nfs = require('fs');\n\nfile = require('file');\n\nlogger = require('./../logger');\n\nprettifyResponse = require('./../prettify-response');\n\nMarkdownReporter = (function(superClass) {\n  extend(MarkdownReporter, superClass);\n\n  function MarkdownReporter(emitter, stats, tests, path, details) {\n    MarkdownReporter.__super__.constructor.call(this);\n    this.type = 'markdown';\n    this.stats = stats;\n    this.tests = tests;\n    this.path = this.sanitizedPath(path);\n    this.buf = '';\n    this.level = 1;\n    this.details = details;\n    this.configureEmitter(emitter);\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n  }\n\n  MarkdownReporter.prototype.sanitizedPath = function(path) {\n    var filePath;\n    filePath = path != null ? file.path.abspath(path) : file.path.abspath(\"./report.md\");\n    if (fs.existsSync(filePath)) {\n      logger.info(\"File exists at \" + filePath + \", will be overwritten...\");\n    }\n    return filePath;\n  };\n\n  MarkdownReporter.prototype.configureEmitter = function(emitter) {\n    var title;\n    title = (function(_this) {\n      return function(str) {\n        return Array(_this.level).join(\"#\") + \" \" + str;\n      };\n    })(this);\n    emitter.on('start', (function(_this) {\n      return function(rawBlueprint, callback) {\n        _this.level++;\n        _this.buf += title('Dredd Tests') + \"\\n\";\n        return callback();\n      };\n    })(this));\n    emitter.on('end', (function(_this) {\n      return function(callback) {\n        return fs.writeFile(_this.path, _this.buf, function(err) {\n          if (err) {\n            logger.error(err);\n          }\n          return callback();\n        });\n      };\n    })(this));\n    emitter.on('test start', (function(_this) {\n      return function(test) {\n        return _this.level++;\n      };\n    })(this));\n    emitter.on('test pass', (function(_this) {\n      return function(test) {\n        _this.buf += title(\"Pass: \" + test.title) + \"\\n\";\n        if (_this.details) {\n          _this.level++;\n          _this.buf += title(\"Request\") + \"\\n```\\n\" + prettifyResponse(test.request) + \"\\n```\\n\\n\";\n          _this.buf += title(\"Expected\") + \"\\n```\\n\" + prettifyResponse(test.expected) + \"\\n```\\n\\n\";\n          _this.buf += title(\"Actual\") + \"\\n```\\n\" + prettifyResponse(test.actual) + \"\\n```\\n\\n\";\n          _this.level--;\n        }\n        return _this.level--;\n      };\n    })(this));\n    emitter.on('test skip', (function(_this) {\n      return function(test) {\n        _this.buf += title(\"Skip: \" + test.title) + \"\\n\";\n        return _this.level--;\n      };\n    })(this));\n    emitter.on('test fail', (function(_this) {\n      return function(test) {\n        _this.buf += title(\"Fail: \" + test.title + \"\\n\");\n        _this.level++;\n        _this.buf += title(\"Message\") + \"\\n```\\n\" + test.message + \"\\n```\\n\\n\";\n        _this.buf += title(\"Request\") + \"\\n```\\n\" + prettifyResponse(test.request) + \"\\n```\\n\\n\";\n        _this.buf += title(\"Expected\") + \"\\n```\\n\" + prettifyResponse(test.expected) + \"\\n```\\n\\n\";\n        _this.buf += title(\"Actual\") + \"\\n```\\n\" + prettifyResponse(test.actual) + \"\\n```\\n\\n\";\n        _this.level--;\n        return _this.level--;\n      };\n    })(this));\n    return emitter.on('test error', (function(_this) {\n      return function(error, test) {\n        _this.buf += title(\"Error: \" + test.title + \"\\n\");\n        _this.buf += \"\\n```\\n\";\n        _this.buf += \"\\nError: \\n\" + error + \"\\nStacktrace: \\n\" + error.stack + \"\\n\";\n        _this.buf += \"```\\n\\n\";\n        return _this.level--;\n      };\n    })(this));\n  };\n\n  return MarkdownReporter;\n\n})(EventEmitter);\n\nmodule.exports = MarkdownReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/reporters/apiary-reporter.js":"// Generated by CoffeeScript 1.12.5\nvar ApiaryReporter, CONNECTION_ERRORS, clone, generateUuid, logger, os, packageData, request, url,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  hasProp = {}.hasOwnProperty,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nrequest = require('request');\n\nos = require('os');\n\nurl = require('url');\n\nclone = require('clone');\n\ngenerateUuid = require('uuid').v4;\n\npackageData = require('./../../package.json');\n\nlogger = require('./../logger');\n\nCONNECTION_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE'];\n\nApiaryReporter = (function() {\n  function ApiaryReporter(emitter, stats, tests, config, runner) {\n    this.configureEmitter = bind(this.configureEmitter, this);\n    var base;\n    this.type = 'apiary';\n    this.stats = stats;\n    this.tests = tests;\n    this.uuid = null;\n    this.startedAt = null;\n    this.endedAt = null;\n    this.remoteId = null;\n    this.config = config;\n    this.runner = runner;\n    this.reportUrl = null;\n    this.configureEmitter(emitter);\n    this.errors = [];\n    this.serverError = false;\n    this.configuration = {\n      apiUrl: this._get('apiaryApiUrl', 'APIARY_API_URL', 'https://api.apiary.io'),\n      apiToken: this._get('apiaryApiKey', 'APIARY_API_KEY', null),\n      apiSuite: this._get('apiaryApiName', 'APIARY_API_NAME', null)\n    };\n    logger.verbose(\"Using '\" + this.type + \"' reporter.\");\n    if (!this.configuration.apiToken && !this.configuration.apiSuite) {\n      logger.warn('Apiary API Key or API Project Subdomain were not provided. Configure Dredd to be able to save test reports alongside your Apiary API project: https://dredd.readthedocs.io/en/latest/how-to-guides/#using-apiary-reporter-and-apiary-tests');\n    }\n    if ((base = this.configuration).apiSuite == null) {\n      base.apiSuite = 'public';\n    }\n  }\n\n  ApiaryReporter.prototype._get = function(customProperty, envProperty, defaultVal) {\n    var ref, ref1, ref2, ref3, ref4, ref5, ref6, returnVal;\n    returnVal = defaultVal;\n    if (((ref = this.config.custom) != null ? ref[customProperty] : void 0) != null) {\n      returnVal = this.config.custom[customProperty];\n    } else if (((ref1 = this.config.options) != null ? (ref2 = ref1.custom) != null ? ref2[customProperty] : void 0 : void 0) != null) {\n      returnVal = this.config.options.custom[customProperty];\n    } else if (((ref3 = this.config.custom) != null ? (ref4 = ref3.apiaryReporterEnv) != null ? ref4[customProperty] : void 0 : void 0) != null) {\n      returnVal = this.config.custom.apiaryReporterEnv[customProperty];\n    } else if (((ref5 = this.config.custom) != null ? (ref6 = ref5.apiaryReporterEnv) != null ? ref6[envProperty] : void 0 : void 0) != null) {\n      returnVal = this.config.custom.apiaryReporterEnv[envProperty];\n    } else if (process.env[envProperty] != null) {\n      returnVal = process.env[envProperty];\n    }\n    return returnVal;\n  };\n\n  ApiaryReporter.prototype._getKeys = function() {\n    var ref, returnKeys;\n    returnKeys = [];\n    returnKeys = returnKeys.concat(Object.keys(((ref = this.config.custom) != null ? ref.apiaryReporterEnv : void 0) || {}));\n    return returnKeys.concat(Object.keys(process.env));\n  };\n\n  ApiaryReporter.prototype.configureEmitter = function(emitter) {\n    var _createStep;\n    emitter.on('start', (function(_this) {\n      return function(blueprintsData, callback) {\n        var blueprints, ciEnvVars, ciVars, data, envVarName, envVarNames, filename, i, len, path;\n        if (_this.serverError === true) {\n          return callback();\n        }\n        _this.uuid = generateUuid();\n        _this.startedAt = Math.round(new Date().getTime() / 1000);\n        ciVars = /^(TRAVIS|CIRCLE|CI|DRONE|BUILD_ID)/;\n        envVarNames = _this._getKeys();\n        ciEnvVars = {};\n        for (i = 0, len = envVarNames.length; i < len; i++) {\n          envVarName = envVarNames[i];\n          if (envVarName.match(ciVars) != null) {\n            ciEnvVars[envVarName] = _this._get(envVarName, envVarName);\n          }\n        }\n        blueprints = (function() {\n          var results;\n          results = [];\n          for (filename in blueprintsData) {\n            if (!hasProp.call(blueprintsData, filename)) continue;\n            data = blueprintsData[filename];\n            results.push(data);\n          }\n          return results;\n        })();\n        data = {\n          blueprints: blueprints,\n          endpoint: _this.config.server,\n          agent: _this._get('dreddAgent', 'DREDD_AGENT') || _this._get('user', 'USER'),\n          agentRunUuid: _this.uuid,\n          hostname: _this._get('dreddHostname', 'DREDD_HOSTNAME') || os.hostname(),\n          startedAt: _this.startedAt,\n          \"public\": true,\n          status: 'running',\n          agentEnvironment: ciEnvVars\n        };\n        if ((_this.configuration['apiToken'] != null) && (_this.configuration['apiSuite'] != null)) {\n          data[\"public\"] = false;\n        }\n        path = '/apis/' + _this.configuration['apiSuite'] + '/tests/runs';\n        return _this._performRequestAsync(path, 'POST', data, function(error, response, parsedBody) {\n          if (error) {\n            return callback(error);\n          } else {\n            _this.remoteId = parsedBody['_id'];\n            if (parsedBody['reportUrl']) {\n              _this.reportUrl = parsedBody['reportUrl'];\n            }\n            return callback();\n          }\n        });\n      };\n    })(this));\n    _createStep = (function(_this) {\n      return function(test, callback) {\n        var data, path;\n        if (_this.serverError === true) {\n          return callback();\n        }\n        data = _this._transformTestToReporter(test);\n        path = '/apis/' + _this.configuration['apiSuite'] + '/tests/steps?testRunId=' + _this.remoteId;\n        return _this._performRequestAsync(path, 'POST', data, function(error, response, parsedBody) {\n          if (error) {\n            return callback(error);\n          }\n          return callback();\n        });\n      };\n    })(this);\n    emitter.on('test pass', _createStep);\n    emitter.on('test fail', _createStep);\n    emitter.on('test skip', _createStep);\n    emitter.on('test error', (function(_this) {\n      return function(error, test, callback) {\n        var base, base1, data, path, ref;\n        if (_this.serverError === true) {\n          return callback();\n        }\n        data = _this._transformTestToReporter(test);\n        if ((base = data.resultData).result == null) {\n          base.result = {};\n        }\n        if ((base1 = data.resultData.result).general == null) {\n          base1.general = [];\n        }\n        if (ref = error.code, indexOf.call(CONNECTION_ERRORS, ref) >= 0) {\n          data.resultData.result.general.push({\n            severity: 'error',\n            message: \"Error connecting to server under test!\"\n          });\n        } else {\n          data.resultData.result.general.push({\n            severity: 'error',\n            message: \"Unhandled error occured when executing the transaction.\"\n          });\n        }\n        path = '/apis/' + _this.configuration['apiSuite'] + '/tests/steps?testRunId=' + _this.remoteId;\n        return _this._performRequestAsync(path, 'POST', data, function(error, response, parsedBody) {\n          if (error) {\n            return callback(error);\n          }\n          return callback();\n        });\n      };\n    })(this));\n    return emitter.on('end', (function(_this) {\n      return function(callback) {\n        var data, path, ref, ref1;\n        if (_this.serverError === true) {\n          return callback();\n        }\n        data = {\n          endedAt: Math.round(new Date().getTime() / 1000),\n          result: _this.stats,\n          status: _this.stats['failures'] > 0 || _this.stats['errors'] > 0 ? 'failed' : 'passed',\n          logs: ((ref = _this.runner) != null ? (ref1 = ref.logs) != null ? ref1.length : void 0 : void 0) ? _this.runner.logs : void 0\n        };\n        path = '/apis/' + _this.configuration['apiSuite'] + '/tests/run/' + _this.remoteId;\n        return _this._performRequestAsync(path, 'PATCH', data, function(error, response, parsedBody) {\n          var reportUrl;\n          if (error) {\n            return callback(error);\n          }\n          reportUrl = _this.reportUrl || (\"https://app.apiary.io/\" + _this.configuration.apiSuite + \"/tests/run/\" + _this.remoteId);\n          logger.complete(\"See results in Apiary at: \" + reportUrl);\n          return callback();\n        });\n      };\n    })(this));\n  };\n\n  ApiaryReporter.prototype._transformTestToReporter = function(test) {\n    var data;\n    data = {\n      testRunId: this.remoteId,\n      origin: test['origin'],\n      duration: test['duration'],\n      result: test['status'],\n      startedAt: test['startedAt'],\n      resultData: {\n        request: test['request'],\n        realResponse: test['actual'],\n        expectedResponse: test['expected'],\n        result: test['results']\n      }\n    };\n    return data;\n  };\n\n  ApiaryReporter.prototype._performRequestAsync = function(path, method, reqBody, callback) {\n    var body, error, handleRequest, headers, options, protocol, system;\n    handleRequest = (function(_this) {\n      return function(err, res, resBody) {\n        var info, parsedBody, ref;\n        if (err) {\n          _this.serverError = true;\n          logger.debug('Requesting Apiary API errored:', (\"\" + err) || err.code);\n          if (ref = err.code, indexOf.call(CONNECTION_ERRORS, ref) >= 0) {\n            return callback(new Error('Apiary reporter could not connect to Apiary API'));\n          } else {\n            return callback(err);\n          }\n        }\n        logger.verbose('Handling HTTP response from Apiary API');\n        try {\n          parsedBody = JSON.parse(resBody);\n        } catch (error1) {\n          err = error1;\n          err = new Error(\"Apiary reporter failed to parse Apiary API response body: \" + err.message + \"\\n\" + resBody);\n          return callback(err);\n        }\n        info = {\n          headers: res.headers,\n          statusCode: res.statusCode,\n          body: parsedBody\n        };\n        logger.debug('Apiary reporter response:', JSON.stringify(info, null, 2));\n        return callback(null, res, parsedBody);\n      };\n    })(this);\n    body = JSON.stringify(reqBody);\n    system = os.type() + ' ' + os.release() + '; ' + os.arch();\n    headers = {\n      'User-Agent': \"Dredd Apiary Reporter/\" + packageData.version + \" (\" + system + \")\",\n      'Content-Type': 'application/json'\n    };\n    options = clone(this.config.http || {});\n    options.uri = this.configuration.apiUrl + path;\n    options.method = method;\n    options.headers = headers;\n    options.body = body;\n    if (this.configuration.apiToken) {\n      options.headers['Authentication'] = 'Token ' + this.configuration.apiToken;\n    }\n    try {\n      protocol = options.uri.split(':')[0].toUpperCase();\n      logger.verbose(\"About to perform an \" + protocol + \" request from Apiary reporter to Apiary API: \" + options.method + \" \" + options.uri + \" (\" + (body ? 'with' : 'without') + \" body)\");\n      logger.debug('Request details:', JSON.stringify({\n        options: options,\n        body: body\n      }, null, 2));\n      return request(options, handleRequest);\n    } catch (error1) {\n      error = error1;\n      logger.debug('Requesting Apiary API errored:', error);\n      return callback(error);\n    }\n  };\n\n  return ApiaryReporter;\n\n})();\n\nmodule.exports = ApiaryReporter;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/config-utils.js":"// Generated by CoffeeScript 1.12.5\nvar clone, configUtils, fs, yaml;\n\nfs = require('fs');\n\nyaml = require('js-yaml');\n\nclone = require('clone');\n\nconfigUtils = {};\n\nconfigUtils.save = function(argsOrigin, path) {\n  var args, key, value, yamlArgs;\n  if (path == null) {\n    path = './dredd.yml';\n  }\n  args = clone(argsOrigin);\n  args['blueprint'] = args['_'][0];\n  args['endpoint'] = args['_'][1];\n  for (key in args) {\n    value = args[key];\n    if (key.length === 1) {\n      delete args[key];\n    }\n  }\n  delete args['$0'];\n  delete args['_'];\n  yamlArgs = yaml.dump(args);\n  return fs.writeFileSync(path, yamlArgs);\n};\n\nconfigUtils.load = function(path) {\n  var data, yamlData;\n  if (path == null) {\n    path = './dredd.yml';\n  }\n  yamlData = fs.readFileSync(path);\n  data = yaml.safeLoad(yamlData);\n  data['_'] = [data['blueprint'], data['endpoint']];\n  delete data['blueprint'];\n  delete data['endpoint'];\n  return data;\n};\n\nconfigUtils.parseCustom = function(customArray) {\n  var i, len, output, splitted, string;\n  output = {};\n  if (Array.isArray(customArray)) {\n    for (i = 0, len = customArray.length; i < len; i++) {\n      string = customArray[i];\n      splitted = string.split(/:(.+)?/);\n      output[splitted[0]] = splitted[1];\n    }\n  }\n  return output;\n};\n\nmodule.exports = configUtils;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/flatten-headers.js":"// Generated by CoffeeScript 1.12.5\nvar flattenHeaders;\n\nflattenHeaders = function(blueprintHeaders) {\n  var flatHeaders, name, values;\n  flatHeaders = {};\n  for (name in blueprintHeaders) {\n    values = blueprintHeaders[name];\n    flatHeaders[name] = values['value'];\n  }\n  return flatHeaders;\n};\n\nmodule.exports = flattenHeaders;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/handle-runtime-problems.js":"// Generated by CoffeeScript 1.12.5\nvar blueprintUtils, handleRuntimeProblems, logger,\n  hasProp = {}.hasOwnProperty;\n\nblueprintUtils = require('./blueprint-utils');\n\nlogger = require('./logger');\n\nhandleRuntimeProblems = function(blueprintData) {\n  var annotation, apiDescriptionDocument, data, error, filename, i, len, log, message, ranges, ref, transactionName;\n  error = false;\n  for (filename in blueprintData) {\n    if (!hasProp.call(blueprintData, filename)) continue;\n    data = blueprintData[filename];\n    apiDescriptionDocument = data.raw;\n    ref = data.annotations;\n    for (i = 0, len = ref.length; i < len; i++) {\n      annotation = ref[i];\n      if (annotation.type === 'warning') {\n        log = logger.warn;\n      } else {\n        error = true;\n        log = logger.error;\n      }\n      if (annotation.component === 'apiDescriptionParser') {\n        ranges = blueprintUtils.warningLocationToRanges(annotation.location, apiDescriptionDocument);\n        message = \"Parser \" + annotation.type + \" in file '\" + filename + \"': (\" + annotation.type + \" code \" + annotation.code + \") \" + annotation.message + \" \";\n        if (ranges != null ? ranges.length : void 0) {\n          message += \"on \" + (blueprintUtils.rangesToLinesText(ranges));\n        }\n        log(message);\n      } else {\n        transactionName = [annotation.origin.resourceGroupName, annotation.origin.resourceName, annotation.origin.actionName].join(' > ');\n        log(\"Compilation \" + annotation.type + \" in file '\" + filename + \"': \" + annotation.message + \" (\" + transactionName + \") \");\n      }\n    }\n  }\n  if (error) {\n    return new Error('Error when processing API description.');\n  }\n};\n\nmodule.exports = handleRuntimeProblems;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/interactive-config.js":"// Generated by CoffeeScript 1.12.5\nvar fs, inquirer, interactiveConfig, packageData, yaml;\n\ninquirer = require('inquirer');\n\nfs = require('fs');\n\nyaml = require('js-yaml');\n\npackageData = require('../package.json');\n\ninteractiveConfig = {};\n\ninteractiveConfig.prompt = function(config, callback) {\n  var questions, ref, ref1;\n  if (config == null) {\n    config = {};\n  }\n  questions = [];\n  questions.push({\n    type: \"input\",\n    name: \"blueprint\",\n    message: \"Location of the API description document\",\n    \"default\": config['blueprint'] || \"apiary.apib\"\n  });\n  questions.push({\n    type: \"input\",\n    name: \"server\",\n    message: \"Command to start API backend server e.g. (bundle exec rails server)\",\n    \"default\": config['server']\n  });\n  questions.push({\n    type: \"input\",\n    name: \"endpoint\",\n    message: \"URL of tested API endpoint\",\n    \"default\": config['endpoint'] || \"http://127.0.0.1:3000\"\n  });\n  questions.push({\n    type: \"list\",\n    name: \"language\",\n    message: \"Programming language of hooks\",\n    \"default\": \"nodejs\",\n    choices: [\"ruby\", \"python\", \"nodejs\", \"php\", \"perl\", \"go\"]\n  });\n  questions.push({\n    type: \"confirm\",\n    name: \"apiary\",\n    message: \"Do you want to use Apiary test inspector?\",\n    \"default\": true,\n    when: function(answers) {\n      return config['reporter'] !== 'apiary';\n    }\n  });\n  questions.push({\n    type: \"input\",\n    name: \"apiaryApiKey\",\n    message: \"Please enter Apiary API key or leave empty for anonymous reporter\",\n    \"default\": (ref = config['custom']) != null ? ref['apiaryApiKey'] : void 0,\n    when: function(answers) {\n      var ref1;\n      return answers['apiary'] === true && (((ref1 = config['custom']) != null ? ref1['apiaryApiKey'] : void 0) == null);\n    }\n  });\n  questions.push({\n    type: \"input\",\n    name: \"apiaryApiName\",\n    message: \"Please enter Apiary API name\",\n    \"default\": (ref1 = config['custom']) != null ? ref1['apiaryApiName'] : void 0,\n    when: function(answers) {\n      var ref2;\n      return (answers['apiary'] === true && (((ref2 = config['custom']) != null ? ref2['apiaryApiName'] : void 0) == null)) && (answers['apiary'] === true && answers['apiaryApiKey'] !== '');\n    }\n  });\n  questions.push({\n    type: \"confirm\",\n    name: \"travisAdd\",\n    message: \"Found Travis CI configuration, do you want to add Dredd to the build?\",\n    \"default\": true,\n    when: function() {\n      return fs.existsSync('.travis.yml');\n    }\n  });\n  questions.push({\n    type: \"confirm\",\n    name: \"circleAdd\",\n    message: \"Found CircleCI configuration, do you want to add Dredd to the build?\",\n    \"default\": true,\n    when: function() {\n      return fs.existsSync('circle.yml');\n    }\n  });\n  questions.push({\n    type: \"confirm\",\n    name: \"circleCreate\",\n    message: \"Dredd is best served with Continuous Integration. Create CircleCI config for Dredd?\",\n    when: function(answers) {\n      return !fs.existsSync('circle.yml') && !fs.existsSync('.travis.yml');\n    }\n  });\n  return inquirer.prompt(questions).then(callback);\n};\n\ninteractiveConfig.processAnswers = function(config, answers, callback) {\n  if (config == null) {\n    config = {};\n  }\n  if (config['_'] == null) {\n    config['_'] = [];\n  }\n  config['_'][0] = answers['blueprint'];\n  config['_'][1] = answers['endpoint'];\n  config['server'] = answers['server'] || null;\n  config['language'] = answers['language'];\n  if (answers['apiary'] === true) {\n    config['reporter'] = \"apiary\";\n  }\n  if (config['custom'] == null) {\n    config['custom'] = {};\n  }\n  if (answers['apiaryApiKey'] != null) {\n    config['custom']['apiaryApiKey'] = answers['apiaryApiKey'];\n  }\n  if (answers['apiaryApiName'] != null) {\n    config['custom']['apiaryApiName'] = answers['apiaryApiName'];\n  }\n  if (answers['circleAdd'] || answers['circleCreate']) {\n    interactiveConfig.updateCircle();\n  }\n  if (answers['travisAdd'] === true) {\n    interactiveConfig.updateTravis();\n  }\n  callback(config);\n};\n\ninteractiveConfig.run = function(config, callback) {\n  interactiveConfig.prompt(config, function(answers) {\n    return interactiveConfig.processAnswers(config, answers, callback);\n  });\n};\n\ninteractiveConfig.updateCircle = function() {\n  var base, base1, config, file, yamlData;\n  file = \"circle.yml\";\n  if (fs.existsSync(file)) {\n    config = yaml.safeLoad(fs.readFileSync(file));\n  } else {\n    config = {};\n  }\n  if (config['dependencies'] == null) {\n    config['dependencies'] = {};\n  }\n  if ((base = config['dependencies'])['pre'] == null) {\n    base['pre'] = [];\n  }\n  if (config['dependencies']['pre'].indexOf(\"npm install -g dredd\") === -1) {\n    config['dependencies']['pre'].push(\"npm install -g dredd@\" + packageData.version);\n  }\n  if (config['test'] == null) {\n    config['test'] = {};\n  }\n  if ((base1 = config['test'])['pre'] == null) {\n    base1['pre'] = [];\n  }\n  if (config['test']['pre'].indexOf(\"dredd\") === -1) {\n    config['test']['pre'].push(\"dredd\");\n  }\n  yamlData = yaml.safeDump(config);\n  fs.writeFileSync(file, yamlData);\n};\n\ninteractiveConfig.updateTravis = function() {\n  var config, file, yamlData;\n  file = \".travis.yml\";\n  if (fs.existsSync(file)) {\n    config = yaml.safeLoad(fs.readFileSync(file));\n  } else {\n    config = {};\n  }\n  if (config['before_install'] == null) {\n    config['before_install'] = [];\n  }\n  if (config['before_install'].indexOf(\"npm install -g dredd\") === -1) {\n    config['before_install'].push(\"npm install -g dredd@\" + packageData.version);\n  }\n  if (config['before_script'] == null) {\n    config['before_script'] = [];\n  }\n  if (config['before_script'].indexOf(\"dredd\") === -1) {\n    config['before_script'].push(\"dredd\");\n  }\n  yamlData = yaml.safeDump(config);\n  fs.writeFileSync(file, yamlData);\n};\n\nmodule.exports = interactiveConfig;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/options.js":"// Generated by CoffeeScript 1.12.5\nvar options;\n\noptions = {\n  \"dry-run\": {\n    alias: 'y',\n    description: 'Do not run any real HTTP transaction, only parse API description document and compile transactions.',\n    \"default\": null\n  },\n  hookfiles: {\n    alias: 'f',\n    description: 'Specifies a pattern to match files with before/after hooks for running tests',\n    \"default\": null\n  },\n  language: {\n    alias: \"a\",\n    description: \"Language of hookfiles. Possible options are: nodejs, ruby, python, php, perl, go\",\n    \"default\": \"nodejs\"\n  },\n  sandbox: {\n    alias: 'b',\n    description: \"Load and run non trusted hooks code in sandboxed container\",\n    \"default\": false\n  },\n  server: {\n    alias: 'g',\n    description: 'Run API backend server command and kill it after Dredd execution. E.g. `rails server`',\n    \"default\": null\n  },\n  \"server-wait\": {\n    description: \"Set delay time in seconds between running a server and test run.\",\n    \"default\": 3\n  },\n  init: {\n    alias: 'i',\n    description: \"Run interactive configuration. Creates dredd.yml configuration file.\",\n    \"default\": false\n  },\n  custom: {\n    alias: 'j',\n    description: \"Pass custom key-value configuration data delimited by a colon. E.g. -j 'a:b'\",\n    \"default\": []\n  },\n  names: {\n    alias: 'n',\n    description: 'Only list names of requests (for use in a hookfile). No requests are made.',\n    \"default\": false\n  },\n  only: {\n    alias: \"x\",\n    description: \"Run only specified transaction name. Can be used multiple times\",\n    \"default\": []\n  },\n  reporter: {\n    alias: \"r\",\n    description: \"Output additional report format. This option can be used multiple times to add multiple reporters. Options: junit, nyan, dot, markdown, html, apiary.\\n\",\n    \"default\": []\n  },\n  output: {\n    alias: \"o\",\n    description: \"Specifies output file when using additional file-based reporter. This option can be used multiple times if multiple file-based reporters are used.\\n\",\n    \"default\": []\n  },\n  header: {\n    alias: \"h\",\n    description: \"Extra header to include in every request. This option can be used multiple times to add multiple headers.\\n\",\n    \"default\": []\n  },\n  sorted: {\n    alias: \"s\",\n    description: \"Sorts requests in a sensible way so that objects are not modified before they are created. Order: CONNECT, OPTIONS, POST, GET, HEAD, PUT, PATCH, DELETE, TRACE.\\n\",\n    \"default\": false\n  },\n  user: {\n    alias: \"u\",\n    description: \"Basic Auth credentials in the form username:password.\\n\",\n    \"default\": null\n  },\n  \"inline-errors\": {\n    alias: \"e\",\n    description: \"Determines whether failures and errors are displayed as they occur (true) or aggregated and displayed at the end (false).\\n\",\n    \"default\": false\n  },\n  details: {\n    alias: \"d\",\n    description: \"Determines whether request/response details are included in passing tests.\\n\",\n    \"default\": false\n  },\n  method: {\n    alias: \"m\",\n    description: \"Restrict tests to a particular HTTP method (GET, PUT, POST, DELETE, PATCH). This option can be used multiple times to allow multiple methods.\\n\",\n    \"default\": []\n  },\n  color: {\n    alias: \"c\",\n    description: \"Determines whether console output should include colors.\\n\",\n    \"default\": true\n  },\n  level: {\n    alias: \"l\",\n    description: \"The level of logging to output. Options: silly, debug, verbose, info, warn, error.\\n\",\n    \"default\": \"info\"\n  },\n  timestamp: {\n    alias: \"t\",\n    description: \"Determines whether console output should include timestamps.\\n\",\n    \"default\": false\n  },\n  silent: {\n    alias: \"q\",\n    description: \"Silences commandline output.\\n\",\n    \"default\": false\n  },\n  path: {\n    alias: \"p\",\n    description: \"Additional API description paths or URLs. Can be used multiple times with glob pattern for paths.\",\n    \"default\": []\n  },\n  help: {\n    description: \"Show usage information.\\n\"\n  },\n  version: {\n    description: \"Show version number.\\n\"\n  },\n  'hooks-worker-timeout': {\n    description: \"How long to wait for hooks worker to start. [ms]\",\n    \"default\": 5000\n  },\n  'hooks-worker-connect-timeout': {\n    description: 'Total hook worker connection timeout (includes all retries). [ms]',\n    \"default\": 1500\n  },\n  'hooks-worker-connect-retry': {\n    description: 'How long to wait between attempts to connect to hooks worker. [ms]',\n    \"default\": 500\n  },\n  'hooks-worker-after-connect-wait': {\n    description: 'How long to wait between connecting to hooks worker and start of testing. [ms]',\n    \"default\": 100\n  },\n  'hooks-worker-term-timeout': {\n    description: 'How long to wait between trying to terminate hooks worker and killing it. [ms]',\n    \"default\": 5000\n  },\n  'hooks-worker-term-retry': {\n    description: 'How long to wait between attempts to terminate hooks worker. [ms]',\n    \"default\": 500\n  },\n  'hooks-worker-handler-host': {\n    description: 'Host of the hook worker.',\n    \"default\": '127.0.0.1'\n  },\n  'hooks-worker-handler-port': {\n    description: 'Port of the hook worker.',\n    \"default\": 61321\n  },\n  config: {\n    description: 'Path to dredd.yml config file.',\n    \"default\": './dredd.yml'\n  }\n};\n\nmodule.exports = options;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/sort-transactions.js":"// Generated by CoffeeScript 1.12.5\nvar sortTransactions;\n\nsortTransactions = function(arr) {\n  arr.map(function(a, i) {\n    return a['_index'] = i;\n  });\n  arr.sort(function(a, b) {\n    var methodIndexA, methodIndexB, sortedMethods;\n    sortedMethods = [\"CONNECT\", \"OPTIONS\", \"POST\", \"GET\", \"HEAD\", \"PUT\", \"PATCH\", \"DELETE\", \"TRACE\"];\n    methodIndexA = sortedMethods.indexOf(a['request']['method']);\n    methodIndexB = sortedMethods.indexOf(b['request']['method']);\n    switch (false) {\n      case !(methodIndexA < methodIndexB):\n        return -1;\n      case !(methodIndexA > methodIndexB):\n        return 1;\n      case methodIndexA !== methodIndexB:\n        return a['_index'] - b['_index'];\n    }\n  });\n  arr.map(function(a) {\n    return delete a['_index'];\n  });\n  return arr;\n};\n\nmodule.exports = sortTransactions;\n","/home/travis/build/npmtest/node-npmtest-dredd/node_modules/dredd/lib/transaction-runner.js":"// Generated by CoffeeScript 1.12.5\nvar Pitboss, TransactionRunner, addHooks, async, caseless, chai, clone, flattenHeaders, gavel, logger, os, packageData, path, requestLib, sandboxedLogLibraryPath, sortTransactions, url,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  hasProp = {}.hasOwnProperty;\n\nrequestLib = require('request');\n\nurl = require('url');\n\npath = require('path');\n\nos = require('os');\n\nchai = require('chai');\n\ngavel = require('gavel');\n\nasync = require('async');\n\nclone = require('clone');\n\ncaseless = require('caseless');\n\nPitboss = require('pitboss-ng').Pitboss;\n\nflattenHeaders = require('./flatten-headers');\n\naddHooks = require('./add-hooks');\n\nsortTransactions = require('./sort-transactions');\n\npackageData = require('./../package.json');\n\nlogger = require('./logger');\n\nsandboxedLogLibraryPath = '../../../lib/hooks-log-sandboxed';\n\nTransactionRunner = (function() {\n  function TransactionRunner(configuration1) {\n    this.configuration = configuration1;\n    this.executeTransaction = bind(this.executeTransaction, this);\n    this.configureTransaction = bind(this.configureTransaction, this);\n    this.logs = [];\n    this.hookStash = {};\n    this.error = null;\n    this.hookHandlerError = null;\n  }\n\n  TransactionRunner.prototype.config = function(config) {\n    this.configuration = config;\n    return this.multiBlueprint = Object.keys(this.configuration.data).length > 1;\n  };\n\n  TransactionRunner.prototype.run = function(transactions, callback) {\n    logger.verbose('Sorting HTTP transactions');\n    transactions = this.configuration.options['sorted'] ? sortTransactions(transactions) : transactions;\n    logger.verbose('Configuring HTTP transactions');\n    return async.mapSeries(transactions, this.configureTransaction.bind(this), (function(_this) {\n      return function(err, results) {\n        transactions = results;\n        logger.verbose('Reading hook files and registering hooks');\n        return addHooks(_this, transactions, function(addHooksError) {\n          if (addHooksError) {\n            return callback(addHooksError);\n          }\n          logger.verbose('Executing HTTP transactions');\n          return _this.executeAllTransactions(transactions, _this.hooks, callback);\n        });\n      };\n    })(this));\n  };\n\n  TransactionRunner.prototype.executeAllTransactions = function(transactions, hooks, callback) {\n    var i, len, transaction;\n    if (!hooks.transactions) {\n      hooks.transactions = {};\n      for (i = 0, len = transactions.length; i < len; i++) {\n        transaction = transactions[i];\n        hooks.transactions[transaction.name] = transaction;\n      }\n    }\n    if (this.hookHandlerError) {\n      return callback(this.hookHandlerError);\n    }\n    logger.verbose('Running \\'beforeAll\\' hooks');\n    return this.runHooksForData(hooks.beforeAllHooks, transactions, true, (function(_this) {\n      return function() {\n        if (_this.hookHandlerError) {\n          return callback(_this.hookHandlerError);\n        }\n        return async.timesSeries(transactions.length, function(transactionIndex, iterationCallback) {\n          transaction = transactions[transactionIndex];\n          logger.verbose(\"Processing transaction #\" + (transactionIndex + 1) + \":\", transaction.name);\n          logger.verbose('Running \\'beforeEach\\' hooks');\n          return _this.runHooksForData(hooks.beforeEachHooks, transaction, false, function() {\n            if (_this.hookHandlerError) {\n              return iterationCallback(_this.hookHandlerError);\n            }\n            logger.verbose('Running \\'before\\' hooks');\n            return _this.runHooksForData(hooks.beforeHooks[transaction.name], transaction, false, function() {\n              if (_this.hookHandlerError) {\n                return iterationCallback(_this.hookHandlerError);\n              }\n              return _this.executeTransaction(transaction, hooks, function() {\n                if (_this.hookHandlerError) {\n                  return iterationCallback(_this.hookHandlerError);\n                }\n                logger.verbose('Running \\'afterEach\\' hooks');\n                return _this.runHooksForData(hooks.afterEachHooks, transaction, false, function() {\n                  if (_this.hookHandlerError) {\n                    return iterationCallback(_this.hookHandlerError);\n                  }\n                  logger.verbose('Running \\'after\\' hooks');\n                  return _this.runHooksForData(hooks.afterHooks[transaction.name], transaction, false, function() {\n                    if (_this.hookHandlerError) {\n                      return iterationCallback(_this.hookHandlerError);\n                    }\n                    logger.debug(\"Evaluating results of transaction execution #\" + (transactionIndex + 1) + \":\", transaction.name);\n                    return _this.emitResult(transaction, iterationCallback);\n                  });\n                });\n              });\n            });\n          });\n        }, function(iterationError) {\n          if (iterationError) {\n            return callback(iterationError);\n          }\n          logger.verbose('Running \\'afterAll\\' hooks');\n          return _this.runHooksForData(hooks.afterAllHooks, transactions, true, function() {\n            if (_this.hookHandlerError) {\n              return callback(_this.hookHandlerError);\n            }\n            return callback();\n          });\n        });\n      };\n    })(this));\n  };\n\n  TransactionRunner.prototype.runHooksForData = function(hooks, data, legacy, callback) {\n    var runHookWithData;\n    if (legacy == null) {\n      legacy = false;\n    }\n    if ((hooks != null) && Array.isArray(hooks)) {\n      logger.debug('Running hooks...');\n      runHookWithData = (function(_this) {\n        return function(hookFnIndex, runHookCallback) {\n          var error, hookFn, i, len, transaction, transactions;\n          hookFn = hooks[hookFnIndex];\n          try {\n            if (legacy) {\n              return _this.runLegacyHook(hookFn, data, function(err) {\n                if (err) {\n                  logger.debug('Legacy hook errored:', err);\n                  _this.emitHookError(err, data);\n                }\n                return runHookCallback();\n              });\n            } else {\n              return _this.runHook(hookFn, data, function(err) {\n                if (err) {\n                  logger.debug('Hook errored:', err);\n                  _this.emitHookError(err, data);\n                }\n                return runHookCallback();\n              });\n            }\n          } catch (error1) {\n            error = error1;\n            if (error instanceof chai.AssertionError) {\n              transactions = Array.isArray(data) ? data : [data];\n              for (i = 0, len = transactions.length; i < len; i++) {\n                transaction = transactions[i];\n                _this.failTransaction(transaction, \"Failed assertion in hooks: \" + error.message);\n              }\n            } else {\n              logger.debug('Hook errored:', error);\n              _this.emitHookError(error, data);\n            }\n            return runHookCallback();\n          }\n        };\n      })(this);\n      return async.timesSeries(hooks.length, runHookWithData, function() {\n        return callback();\n      });\n    } else {\n      return callback();\n    }\n  };\n\n  TransactionRunner.prototype.emitHookError = function(error, data) {\n    var test;\n    if (!(error instanceof Error)) {\n      error = new Error(error);\n    }\n    test = this.createTest(data);\n    test.request = data.request;\n    return this.emitError(error, test);\n  };\n\n  TransactionRunner.prototype.sandboxedHookResultsHandler = function(err, data, results, callback) {\n    var i, key, len, log, ref, ref1, value;\n    if (results == null) {\n      results = {};\n    }\n    if (err) {\n      return callback(err);\n    }\n    ref = results.data || {};\n    for (key in ref) {\n      value = ref[key];\n      data[key] = value;\n    }\n    this.hookStash = results.stash;\n    if (this.logs == null) {\n      this.logs = [];\n    }\n    ref1 = results.logs || [];\n    for (i = 0, len = ref1.length; i < len; i++) {\n      log = ref1[i];\n      this.logs.push(log);\n    }\n    while (Date.now() - results.now < 0) {}\n    callback();\n  };\n\n  TransactionRunner.prototype.sandboxedWrappedCode = function(hookCode) {\n    return \"// run the hook\\nvar log = _log.bind(null, _logs);\\n\\nvar _func = \" + hookCode + \";\\n_func(_data);\\n\\n// setup the return object\\nvar output = {};\\noutput[\\\"data\\\"] = _data;\\noutput[\\\"stash\\\"] = stash;\\noutput[\\\"logs\\\"] = _logs;\\noutput[\\\"now\\\"] = Date.now();\\noutput;\";\n  };\n\n  TransactionRunner.prototype.runSandboxedHookFromString = function(hookString, data, callback) {\n    var sandbox, wrappedCode;\n    wrappedCode = this.sandboxedWrappedCode(hookString);\n    sandbox = new Pitboss(wrappedCode, {\n      timeout: 500\n    });\n    return sandbox.run({\n      context: {\n        '_data': data,\n        '_logs': [],\n        'stash': this.hookStash\n      },\n      libraries: {\n        '_log': sandboxedLogLibraryPath\n      }\n    }, (function(_this) {\n      return function(err, result) {\n        if (result == null) {\n          result = {};\n        }\n        sandbox.kill();\n        return _this.sandboxedHookResultsHandler(err, data, result, callback);\n      };\n    })(this));\n  };\n\n  TransactionRunner.prototype.runLegacyHook = function(hook, data, callback) {\n    if (typeof hook === 'function') {\n      if (hook.length === 1) {\n        logger.warn('DEPRECATION WARNING!\\n\\nYou are using only one argument for the `beforeAll` or `afterAll` hook function.\\nOne argument hook functions will be treated as synchronous in the near future.\\nTo keep the async behaviour, just define hook function with two parameters.\\n\\nInterface of the hooks functions will be unified soon across all hook functions:\\n\\n - `beforeAll` and `afterAll` hooks will support sync API depending on number of arguments\\n - Signatures of callbacks of all hooks will be the same\\n - First passed argument will be a `transactions` object\\n - Second passed argument will be a optional callback function for async\\n - `transactions` object in `hooks` module object will be removed\\n - Manipulation with transaction data will have to be performed on the first function argument');\n        hook(callback);\n      } else if (hook.length === 2) {\n        hook(data, function() {\n          return callback();\n        });\n      }\n    }\n    if (typeof hook === 'string') {\n      return this.runSandboxedHookFromString(hook, data, callback);\n    }\n  };\n\n  TransactionRunner.prototype.runHook = function(hook, data, callback) {\n    if (typeof hook === 'function') {\n      if (hook.length === 1) {\n        hook(data);\n        callback();\n      } else if (hook.length === 2) {\n        hook(data, function() {\n          return callback();\n        });\n      }\n    }\n    if (typeof hook === 'string') {\n      return this.runSandboxedHookFromString(hook, data, callback);\n    }\n  };\n\n  TransactionRunner.prototype.configureTransaction = function(transaction, callback) {\n    var configuration, configuredTransaction, expected, flatHeaders, fullPath, header, headerKey, headerValue, i, len, mediaType, origin, ref, ref1, request, response, skip, splitIndex, status, system;\n    configuration = this.configuration;\n    origin = transaction.origin, request = transaction.request, response = transaction.response;\n    mediaType = ((ref = configuration.data[origin.filename]) != null ? ref.mediaType : void 0) || 'text/vnd.apiblueprint';\n    if (this.parsedUrl == null) {\n      this.parsedUrl = this.parseServerUrl(configuration.server);\n    }\n    fullPath = this.getFullPath(this.parsedUrl.path, request.uri);\n    flatHeaders = flattenHeaders(request['headers']);\n    if (!flatHeaders['User-Agent']) {\n      system = os.type() + ' ' + os.release() + '; ' + os.arch();\n      flatHeaders['User-Agent'] = \"Dredd/\" + packageData.version + \" (\" + system + \")\";\n    }\n    if (configuration.options.header.length > 0) {\n      ref1 = configuration.options.header;\n      for (i = 0, len = ref1.length; i < len; i++) {\n        header = ref1[i];\n        splitIndex = header.indexOf(':');\n        headerKey = header.substring(0, splitIndex);\n        headerValue = header.substring(splitIndex + 1);\n        flatHeaders[headerKey] = headerValue;\n      }\n    }\n    request['headers'] = flatHeaders;\n    expected = {\n      headers: flattenHeaders(response['headers']),\n      body: response['body'],\n      statusCode: response['status']\n    };\n    if (response['schema']) {\n      expected['bodySchema'] = response['schema'];\n    }\n    if (!this.multiBlueprint) {\n      transaction.name = transaction.name.replace(transaction.origin.apiName + \" > \", \"\");\n    }\n    skip = false;\n    if (mediaType.indexOf('swagger') !== -1) {\n      status = parseInt(response.status, 10);\n      if (status < 200 || status >= 300) {\n        skip = true;\n      }\n    }\n    configuredTransaction = {\n      name: transaction.name,\n      id: request.method + ' ' + request.uri,\n      host: this.parsedUrl.hostname,\n      port: this.parsedUrl.port,\n      request: request,\n      expected: expected,\n      origin: origin,\n      fullPath: fullPath,\n      protocol: this.parsedUrl.protocol,\n      skip: skip\n    };\n    return callback(null, configuredTransaction);\n  };\n\n  TransactionRunner.prototype.parseServerUrl = function(serverUrl) {\n    if (!serverUrl.match(/^https?:\\/\\//i)) {\n      serverUrl = 'http://' + serverUrl.replace(/^[:\\/]*/, '');\n    }\n    return url.parse(serverUrl);\n  };\n\n  TransactionRunner.prototype.getFullPath = function(serverPath, requestPath) {\n    var segment, segments, trailingSlash;\n    if (serverPath === '/') {\n      return requestPath;\n    }\n    if (!requestPath) {\n      return serverPath;\n    }\n    segments = [serverPath, requestPath];\n    segments = (function() {\n      var i, len, results1;\n      results1 = [];\n      for (i = 0, len = segments.length; i < len; i++) {\n        segment = segments[i];\n        results1.push(segment.replace(/^\\/|\\/$/g, ''));\n      }\n      return results1;\n    })();\n    trailingSlash = requestPath !== '/' && requestPath.slice(-1) === '/' ? '/' : '';\n    return '/' + segments.join('/') + trailingSlash;\n  };\n\n  TransactionRunner.prototype.createTest = function(transaction) {\n    return {\n      status: '',\n      title: transaction.id,\n      message: transaction.name,\n      origin: transaction.origin,\n      startedAt: transaction.startedAt\n    };\n  };\n\n  TransactionRunner.prototype.failTransaction = function(transaction, reason) {\n    var base;\n    transaction.fail = true;\n    this.ensureTransactionResultsGeneralSection(transaction);\n    if (reason) {\n      transaction.results.general.results.push({\n        severity: 'error',\n        message: reason\n      });\n    }\n    if (transaction.test == null) {\n      transaction.test = this.createTest(transaction);\n    }\n    transaction.test.status = 'fail';\n    if (reason) {\n      transaction.test.message = reason;\n    }\n    return (base = transaction.test).results != null ? base.results : base.results = transaction.results;\n  };\n\n  TransactionRunner.prototype.skipTransaction = function(transaction, reason) {\n    var base;\n    transaction.skip = true;\n    this.ensureTransactionResultsGeneralSection(transaction);\n    if (reason) {\n      transaction.results.general.results.push({\n        severity: 'warning',\n        message: reason\n      });\n    }\n    if (transaction.test == null) {\n      transaction.test = this.createTest(transaction);\n    }\n    transaction.test.status = 'skip';\n    if (reason) {\n      transaction.test.message = reason;\n    }\n    return (base = transaction.test).results != null ? base.results : base.results = transaction.results;\n  };\n\n  TransactionRunner.prototype.ensureTransactionResultsGeneralSection = function(transaction) {\n    var base, base1;\n    if (transaction.results == null) {\n      transaction.results = {};\n    }\n    if ((base = transaction.results).general == null) {\n      base.general = {};\n    }\n    return (base1 = transaction.results.general).results != null ? base1.results : base1.results = [];\n  };\n\n  TransactionRunner.prototype.emitResult = function(transaction, callback) {\n    if (this.error || !transaction.test) {\n      logger.debug('No emission of test data to reporters', this.error, transaction.test);\n      this.error = null;\n      return callback();\n    }\n    if (transaction.skip) {\n      logger.debug('Emitting to reporters: test skip');\n      this.configuration.emitter.emit('test skip', transaction.test, function() {});\n      return callback();\n    }\n    if (transaction.test.valid) {\n      if (transaction.fail) {\n        this.failTransaction(transaction, \"Failed in after hook: \" + transaction.fail);\n        logger.debug('Emitting to reporters: test fail');\n        this.configuration.emitter.emit('test fail', transaction.test, function() {});\n      } else {\n        logger.debug('Emitting to reporters: test pass');\n        this.configuration.emitter.emit('test pass', transaction.test, function() {});\n      }\n      return callback();\n    }\n    logger.debug('Emitting to reporters: test fail');\n    this.configuration.emitter.emit('test fail', transaction.test, function() {});\n    return callback();\n  };\n\n  TransactionRunner.prototype.emitError = function(error, test) {\n    logger.debug('Emitting to reporters: test error');\n    this.configuration.emitter.emit('test error', error, test, function() {});\n    return this.error = this.error || error;\n  };\n\n  TransactionRunner.prototype.getRequestOptionsFromTransaction = function(transaction) {\n    var options, urlObject;\n    urlObject = {\n      protocol: transaction.protocol,\n      hostname: transaction.host,\n      port: transaction.port\n    };\n    options = clone(this.configuration.http || {});\n    options.uri = url.format(urlObject) + transaction.fullPath;\n    options.method = transaction.request.method;\n    options.headers = transaction.request.headers;\n    options.body = transaction.request.body;\n    options.proxy = false;\n    return options;\n  };\n\n  TransactionRunner.prototype.executeTransaction = function(transaction, hooks, callback) {\n    var m, ref, ref1, ref2, test;\n    if (!callback) {\n      ref = [hooks, void 0], callback = ref[0], hooks = ref[1];\n    }\n    transaction.startedAt = Date.now();\n    test = this.createTest(transaction);\n    logger.debug('Emitting to reporters: test start');\n    this.configuration.emitter.emit('test start', test, function() {});\n    this.ensureTransactionResultsGeneralSection(transaction);\n    if (transaction.skip) {\n      logger.verbose('HTTP transaction was marked in hooks as to be skipped. Skipping');\n      transaction.test = test;\n      this.skipTransaction(transaction, 'Skipped in before hook');\n      return callback();\n    } else if (transaction.fail) {\n      logger.verbose('HTTP transaction was marked in hooks as to be failed. Reporting as failed');\n      transaction.test = test;\n      this.failTransaction(transaction, \"Failed in before hook: \" + transaction.fail);\n      return callback();\n    } else if (this.configuration.options['dry-run']) {\n      logger.info('Dry run. Not performing HTTP request');\n      transaction.test = test;\n      this.skipTransaction(transaction);\n      return callback();\n    } else if (this.configuration.options.names) {\n      logger.info(transaction.name);\n      transaction.test = test;\n      this.skipTransaction(transaction);\n      return callback();\n    } else if (this.configuration.options.method.length > 0 && !(ref1 = transaction.request.method, indexOf.call(this.configuration.options.method, ref1) >= 0)) {\n      logger.info(\"Only \" + (((function() {\n        var i, len, ref2, results1;\n        ref2 = this.configuration.options.method;\n        results1 = [];\n        for (i = 0, len = ref2.length; i < len; i++) {\n          m = ref2[i];\n          results1.push(m.toUpperCase());\n        }\n        return results1;\n      }).call(this)).join(', ')) + \"requests are set to be executed. Not performing HTTP \" + (transaction.request.method.toUpperCase()) + \" request.\");\n      transaction.test = test;\n      this.skipTransaction(transaction);\n      return callback();\n    } else if (this.configuration.options.only.length > 0 && !(ref2 = transaction.name, indexOf.call(this.configuration.options.only, ref2) >= 0)) {\n      logger.info(\"Only '\" + this.configuration.options.only + \"' transaction is set to be executed. Not performing HTTP request for '\" + transaction.name + \"'.\");\n      transaction.test = test;\n      this.skipTransaction(transaction);\n      return callback();\n    } else {\n      return this.performRequestAndValidate(test, transaction, hooks, callback);\n    }\n  };\n\n  TransactionRunner.prototype.setContentLength = function(transaction) {\n    var body, calculatedContentLengthValue, contentLengthHeaderName, contentLengthValue, headers;\n    headers = transaction.request.headers;\n    body = transaction.request.body;\n    contentLengthHeaderName = caseless(headers).has('Content-Length');\n    if (contentLengthHeaderName) {\n      contentLengthValue = parseInt(headers[contentLengthHeaderName], 10);\n      if (body) {\n        calculatedContentLengthValue = Buffer.byteLength(body);\n        if (contentLengthValue !== calculatedContentLengthValue) {\n          logger.warn(\"Specified Content-Length header is \" + contentLengthValue + \", but the real body length is \" + calculatedContentLengthValue + \". Using \" + calculatedContentLengthValue + \" instead.\");\n          return headers[contentLengthHeaderName] = calculatedContentLengthValue;\n        }\n      } else if (contentLengthValue !== 0) {\n        logger.warn(\"Specified Content-Length header is \" + contentLengthValue + \", but the real body length is 0. Using 0 instead.\");\n        return headers[contentLengthHeaderName] = 0;\n      }\n    } else {\n      return headers['Content-Length'] = body ? Buffer.byteLength(body) : 0;\n    }\n  };\n\n  TransactionRunner.prototype.performRequestAndValidate = function(test, transaction, hooks, callback) {\n    var error, handleRequest, requestOptions;\n    this.setContentLength(transaction);\n    requestOptions = this.getRequestOptionsFromTransaction(transaction);\n    handleRequest = (function(_this) {\n      return function(err, res, body) {\n        var real;\n        if (err) {\n          logger.debug('Requesting tested server errored:', (\"\" + err) || err.code);\n          test.title = transaction.id;\n          test.expected = transaction.expected;\n          test.request = transaction.request;\n          _this.emitError(err, test);\n          return callback();\n        }\n        logger.verbose('Handling HTTP response from tested server');\n        real = {\n          statusCode: res.statusCode,\n          headers: res.headers,\n          body: body\n        };\n        transaction['real'] = real;\n        logger.verbose('Running \\'beforeEachValidation\\' hooks');\n        return _this.runHooksForData(hooks != null ? hooks.beforeEachValidationHooks : void 0, transaction, false, function() {\n          if (_this.hookHandlerError) {\n            return callback(_this.hookHandlerError);\n          }\n          logger.verbose('Running \\'beforeValidation\\' hooks');\n          return _this.runHooksForData(hooks != null ? hooks.beforeValidationHooks[transaction.name] : void 0, transaction, false, function() {\n            if (_this.hookHandlerError) {\n              return callback(_this.hookHandlerError);\n            }\n            return _this.validateTransaction(test, transaction, callback);\n          });\n        });\n      };\n    })(this);\n    if (transaction.request['body'] && this.isMultipart(requestOptions)) {\n      this.replaceLineFeedInBody(transaction, requestOptions);\n    }\n    try {\n      return this.performRequest(requestOptions, handleRequest);\n    } catch (error1) {\n      error = error1;\n      logger.debug('Requesting tested server errored:', error);\n      test.title = transaction.id;\n      test.expected = transaction.expected;\n      test.request = transaction.request;\n      this.emitError(error, test);\n      return callback();\n    }\n  };\n\n  TransactionRunner.prototype.performRequest = function(options, callback) {\n    var protocol;\n    protocol = options.uri.split(':')[0].toUpperCase();\n    logger.verbose(\"About to perform an \" + protocol + \" request to the server under test: \" + options.method + \" \" + options.uri);\n    return requestLib(options, callback);\n  };\n\n  TransactionRunner.prototype.validateTransaction = function(test, transaction, callback) {\n    var configuration;\n    configuration = this.configuration;\n    logger.verbose('Validating HTTP transaction by Gavel.js');\n    logger.debug('Determining whether HTTP transaction is valid (getting boolean verdict)');\n    return gavel.isValid(transaction.real, transaction.expected, 'response', (function(_this) {\n      return function(isValidError, isValid) {\n        if (isValidError) {\n          logger.debug('Gavel.js validation errored:', isValidError);\n          _this.emitError(isValidError, test);\n        }\n        test.title = transaction.id;\n        test.actual = transaction.real;\n        test.expected = transaction.expected;\n        test.request = transaction.request;\n        if (isValid) {\n          test.status = 'pass';\n        } else {\n          test.status = 'fail';\n        }\n        logger.debug('Validating HTTP transaction (getting verbose validation result)');\n        return gavel.validate(transaction.real, transaction.expected, 'response', function(validateError, gavelResult) {\n          var gavelError, i, len, message, rawValidatorOutput, ref, ref1, results, sectionName, validatorOutput;\n          if (!isValidError && validateError) {\n            logger.debug('Gavel.js validation errored:', validateError);\n            _this.emitError(validateError, test);\n          }\n          message = '';\n          ref = gavelResult || {};\n          for (sectionName in ref) {\n            if (!hasProp.call(ref, sectionName)) continue;\n            validatorOutput = ref[sectionName];\n            if (sectionName !== 'version') {\n              ref1 = validatorOutput.results || [];\n              for (i = 0, len = ref1.length; i < len; i++) {\n                gavelError = ref1[i];\n                message += sectionName + \": \" + gavelError.message + \"\\n\";\n              }\n            }\n          }\n          test.message = message;\n          results = transaction.results || {};\n          for (sectionName in gavelResult) {\n            if (!hasProp.call(gavelResult, sectionName)) continue;\n            rawValidatorOutput = gavelResult[sectionName];\n            if (!(sectionName !== 'version')) {\n              continue;\n            }\n            if (results[sectionName] == null) {\n              results[sectionName] = {};\n            }\n            validatorOutput = clone(rawValidatorOutput);\n            if (results[sectionName].results) {\n              validatorOutput.results = validatorOutput.results.concat(results[sectionName].results);\n            }\n            results[sectionName] = validatorOutput;\n          }\n          transaction.results = results;\n          test.results = transaction.results;\n          test.valid = isValid;\n          transaction.test = test;\n          return callback();\n        });\n      };\n    })(this));\n  };\n\n  TransactionRunner.prototype.isMultipart = function(requestOptions) {\n    var caseInsensitiveRequestHeaders, key, ref, ref1, value;\n    caseInsensitiveRequestHeaders = {};\n    ref = requestOptions.headers;\n    for (key in ref) {\n      value = ref[key];\n      caseInsensitiveRequestHeaders[key.toLowerCase()] = value;\n    }\n    return ((ref1 = caseInsensitiveRequestHeaders['content-type']) != null ? ref1.indexOf(\"multipart\") : void 0) > -1;\n  };\n\n  TransactionRunner.prototype.replaceLineFeedInBody = function(transaction, requestOptions) {\n    if (transaction.request['body'].indexOf('\\r\\n') === -1) {\n      transaction.request['body'] = transaction.request['body'].replace(/\\n/g, '\\r\\n');\n      transaction.request['headers']['Content-Length'] = Buffer.byteLength(transaction.request['body'], 'utf8');\n      return requestOptions.headers = transaction.request['headers'];\n    }\n  };\n\n  return TransactionRunner;\n\n})();\n\nmodule.exports = TransactionRunner;\n"}